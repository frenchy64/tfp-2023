* Point of the derivation in this paper is:

* With the macro based variants, we end up building heavily nested lambdas.

The “naturally-recursive” macro-based implementations we came up with
go the wrong direction. They nest the goals unfortunately, in ways
that we can see in Redex.

** Show how using var-args for functions points the way to the correct definitions

We should be able to _see_ from the derivation how a clean definition
brings us to right behavior.

** Just switching to var-args functions isn’t enough!

Just working with var-args functions isn’t enough; we could define the
logic operators associating the “right way” just as easily as defining
them the “wrong way”. So we need some more subtle categorization.

* ~conda~

It seemed like ~conda~ had forced our hand into including the
zero-ary base case. If we wanted to build out of earlier primitives,
we had needed the zero-ary version for conda. Bracket that concern for
a second, and let’s otherwise say we don’t need that additional case.

* We already have this collection of *8* different obvious implementations.

We can implement the 2+-ary versions, using conj2/disj2 as primitives,
in either the tail recursive or the natl. recursive versions, with
either macros or varargs, either forwards or backwards. So that’s a
nice place to start. Note, that left or right association and left or
right fold are the same, because the operator is binary
conj2/disj2---association is fold. Selecting a starting operator
conj2 v. disj2 is not an axis of variation; any successful approach
must work for both.

* Suppose we _want_ to implement the 1+ary versions.

Why would you want to do that? Macros, for instance. The ~(C g)~ case
matters b/c, say, some ~conde~ macro, or ~fresh~ if you wanted. Maybe
it would suck if the user had to think about whether their ~fresh~
body had 1 or 2+ goals in it. But suppose you didn’t care about that,
either, and that you didn’t need the singleton conjunction case
either. Then we can pick from a smörgåsbord of options.

** We derivation our “clean” version from one of these short recursive variants.

So, which one is this?---~varargs-2+-left-assoc~

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(cond
	  ((null? gs) ((conj2 g1 g2) s))
	  (else ((apply C (cons (conj2 g1 g2) gs)) s))))
#+end_src

We can start by breaking the function up into a recursive variant and
an external-facing help function. Unlike the earlier recursive variant
above, this inner recursive function does not require ~apply~ since it
uses ordinary list recursion.

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g1 g2 gs s))

  (define (C-rec g1 g2 gs s)
	(cond
	  ((null? gs) ((conj2 g1 g2) s))
	  (else
	   (C-rec (conj2 g1 g2) (car gs) (cdr gs) s))))
#+end_src

If we substitute through in the definition of ~conj2~, we get:

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g1 g2 gs s))

  (define (C-rec g1 g2 gs s)
	(cond
	  ((null? gs) ((lambda (s) ($append-map g2 (g1 s))) s))
	  (else
	   (C-rec (lambda (s) ($append-map g2 (g1 s))) (car gs) (cdr gs) s))))
#+end_src

Here is the important piece; since we only need ~s~ to *build the
stream*, we can assemble the stream on the way /in/, and accumulate
along it---instead of passing in g1 and s separately, we pass in their
combination as a stream. The function is tail recursive, we can change
the signature in the one and only external call and the recursive
call.

We had to combine and hand substitute through, as in ~((lambda (s)
($append-map g2 (g1 s))) s)~

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g2 gs (g1 s)))

  (define (C-rec g2 gs s-inf)
	(cond
	  ((null? gs) ($append-map g2 s-inf))
	  (else (C-rec (car gs) (cdr gs) ($append-map g2 s-inf)))))
#+end_src

The recursion and the base case share a lot in common. We can exploit
that. If we pass back the stream in the base case, and split ~gs~ in
the recursive case, we can get rid of ~g2~ and turn this into a 1+ary
version.

#+begin_src racket
  #lang racket
  (define ((C g1 . gs) s)
	(C-rec gs (g1 s)))

  (define (C-rec gs s-inf)
	(cond
	  ((null? gs) s-inf)
	  (else (C-rec (cdr gs) ($append-map (car gs) s-inf)))))
#+end_src

And there you have it. We can derive this answer _from_ the original
version. Both the first version and this final version have their
virtues and drawbacks; one uses explicit ~car~ and ~cdr~, while the
other uses apply. I think we prefer this last one, because it’s
strictly more general.

This “derivation sequence” is essentially a three step operation: 1.
take an operation based on conj2/disj2 and then go beneath that
level 2. some simple clean-up optimizations 3. reduce the demanded
arity so that it operates on 1+ arguments.

It could be nice to avoid having to specialize our macros to the two
different cases and keep our users from needing to worry adding and
removing a combinator when moving from one to more than one goal.

#+begin_src racket
	#lang racket

	(define-syntax fresh
	  (syntax-rules ()
		[(fresh () g) <do something on this one>]
		[(fresh () g g1 g* ...) <do something on this one>]
		[(fresh (x ...) g ...) <recur here down to base case>]))
#+end_src

To illustrate just how superfluous the 0-arity version is, see that we
can add that back in as a separate case of the interface function.

#+begin_src racket
  #lang racket
  (define ((C . gs) s)
	(cond
	  ((null? gs) S)
	  (else (C-rec (cdr gs) ((car gs) s)))))

  (define (C-rec gs s-inf)
	(cond
	  ((null? gs) s-inf)
	  (else (C-rec (cdr gs) ($append-map (car gs) s-inf)))))
#+end_src

** So. Can we do the same thing for *all* of those variants?

Is this transformation sequence (or some analogous version of it)
equally applicable across all of the 4 varags versions?

* Open question.

To recapitulate, our initial motivation was to remove some macros.
This led to using variadic functions to combine arbitrary-length goal
sequences. I want to tell a story where many, if not all, of the
decisions fell out as a consequence of this choice. Can we do that?

** Let’s try and do a similar derivation from one of the other versions.

I want to try one of the more interesting variants. I’m actually
interested in all four versions, because I want to know whether we can
get tail recursive ~disj~ taking its arguments the right way, and
ensuring that we /cannot/ do a similar derivation for the natl.
recursive variants, and for good reason. If we can do that, everything
is aces and this is a good paper. If we are stuck with the
backward-disj, then that’s okay but not great.

#+begin_src racket
#lang racket
  (define ((conj g g1 . gs) s)
  (cond
	((null? gs) ((conj2 g g1) s))
	(else ((conj2 g (apply conj (cons g1 gs))) s))))
#+end_src

So, alright. We’ll try it this way. Break it apart into a recursive
and non-recursive fragment.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  (C-rec g g1 gs s))

  (define (C-rec g g1 gs s)
	(cond
	  ((null? gs) ((conj2 g g1) s))
	  (else ((conj2 g (C-rec g1 (car gs) (cdr gs) s)) s))))
  ;; Cf ((conj2 g (apply conj (cons g1 gs))) s)
#+end_src

And then we try and substitute through the definition of ~conj2~.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  (C-rec g g1 gs s))

  (define (C-rec g g1 gs s)
	(cond
	  ((null? gs) ((λ (s) ($append-map g1 (g s))) s))
	  (else ((λ (s) ($append-map (C-rec g1 (car gs) (cdr gs) s) (g s))) s))))
#+end_src

Okay, now this must be where things get different. Because in the
earlier version, we could construct the stream on the way /down/. Can
we not do that here?

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  (C-rec g g1 gs s))

  (define (C-rec g g1 gs s)
	(cond
	  ((null? gs) ((λ (s) ($append-map g1 (g s))) s))
	  (else ((λ (s) ($append-map (C-rec g1 (car gs) (cdr gs) s) (g s))) s))))
#+end_src

Here it doesn’t look like the ~lambda~ is doing anything for us, and
we can ~β~-reduce those.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  (C-rec g g1 gs s))

  (define (C-rec g g1 gs s)
	(cond
	  ((null? gs) ($append-map g1 (g s)))
	  (else ($append-map (C-rec g1 (car gs) (cdr gs) s) (g s)))))
#+end_src

We can try to pass the stream in, and see what that does.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  (C-rec g1 gs s (g s)))

  (define (C-rec g1 gs s s-inf)
	(cond
	  ((null? gs) ($append-map g1 s-inf))
	  (else ($append-map (C-rec g1 (car gs) (cdr gs) s) s-inf))))
#+end_src

And we could curry the ~$append-map~, pull the stream back, and that gets a little something.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  ((C-rec g1 gs s) (g s)))

  (define ((C-rec g1 gs s) s-inf)
	(cond
	  ((null? gs) ((curry $append-map g1) s-inf))
	  (else ((curry $append-map (C-rec g1 (car gs) (cdr gs) s)) s-inf))))
#+end_src

And we can kind of ~eta~-reduce that definition.

#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  ((C-rec g1 gs s) (g s)))

  (define (C-rec g1 gs s)
	(cond
	  ((null? gs) (curry $append-map g1))
	  (else (curry $append-map (C-rec g1 (car gs) (cdr gs) s)))))
#+end_src

But I’m having trouble understanding how one is obviously a worse
definition, or how one permits an optimization the other clearly
forbids, in a way that leads to the thesis "basic programming skills
get us to the clever definition." Do I want to go with “the 1+ary
version looks uglier”?


#+begin_src racket
  #lang racket
	(define ((conj g g1 . gs) s)
	  ((C-rec g1 gs s) (g s)))

  (define (C-rec g1 gs s)
	(cond
	  ((null? gs) (curry $append-map g1))
	  (else (curry $append-map (C-rec g1 (car gs) (cdr gs) s)))))
#+end_src


** Some other older try I’m not thinking about right now. Detritus.

#+begin_src racket
  #lang racket
  (define ((C g g1 . gs) s)
  (cond
    ((null? gs) (append-map g (g1 s)))
    (else (append-map g ((apply C (cons g1 gs)) s)))))

#+end_src

Which is to say

#+begin_src racket
#lang racket
  (define ((conj2 g g1) s)
	(append-map g (g1 s)))

  (define ((C g g1 . gs) s)
	(cond
	  ((null? gs) ((conj2 g g1) s))
	  (else ((conj2 g (apply C (cons g1 gs))) s))))
#+end_src

And that works. We could have in the recursion associated it the other way

#+begin_src racket
  #lang racket

  (define ((C g g1 . gs) s)
  (cond
	((null? gs) ((conj2 g g1) s))
	(else ((apply C (cons (conj2 g g1) gs)) s))))

#+end_src
What about in the version before that?

#+begin_src racket
  #lang racket
  ;; ne-listof goals -> s -> $tr
(define ((C g . gs) s)
  (cond
    ((null? gs) (g s))
    (else (append-map g ((apply C gs) s)))))


(define ((C g₁ . gs) s)
  (C-rec (g₁ s) gs))

(define (C-rec s∞ gs)
  (cond
    ((null? gs) s∞)
    (else
      (C-rec (append-map (car gs) s∞) (cdr gs)))))


#+end_src

It would be unfortunate to mandate

This list of goals then needed to be processed one at a
time and build a resulting stream of answers.


#+begin_src racket
  #lang racket
  (define ((D . gs) s)
  (cond
    ((null? gs) (list s))
    (else (g s))))


#+end_src

1. I mean, honestly. That 0-ary base case needs to go. We gotta get rid of that.
2. To get rid of macro, start with 2-ary versions. These blend easily.
1. To avoid the macro
2. need variadic functions and recursively process arg list.
: oughnt't introduce artificial extra goals in base case.
: oughtn't need artificial base cases
: need to come in with an initial value for the accumulator
: so need to demand at least one goal to start with


(define-syntax conj
  (syntax-rules ()
    ((conj) S)
    ((conj g) g)
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))


;; wasted disj attempt


(define ((D . gs) s)
  ...)

Since \rackinline|gs| could be empty, as with the macro based
implementation we introduce a base-case for the zero-length list.

(define ((D . gs) s)
  (cond
    ((null? gs) (list))
    ...))

But it's also unfortunate to force an extra failing recursion onto every call,
so we add the length-one arguments list to short-circuit that.

(define ((D . gs) s)
  (cond
    ((null? gs) '())
    ((null? (cdr gs)) (g s))
    ...))

;; These assume 2+ goals; and we don’t write or work w/ “silly conjunctions.”

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj (disj₂ g0 g1) g ...))))

;; These next two are from the paper, as written.
;; As they’re written, they are 0-or-more-ary.
;; But they likewise shouldn’t require silly arities.

(define-syntax conj
  (syntax-rules ()
    ((conj) S)
    ((conj g) g)
    ((conj g0 g ...) (conj₂ g0 (conj g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj) F)
    ((disj g) g)
    ((disj g0 g ...) (disj₂ g0 (disj g ...)))))

;; So we first remove the zero arity, conda be damned.

(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g0 g ...) (conj₂ g0 (conj g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g0 g ...) (disj₂ g0 (disj g ...)))))

;; Then, we try again and unfold the recursion once more

(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g0 g1) (conj₂ g0 (conj g1)))
    ((conj g0 g1 g ...) (conj₂ g0 (conj g1 g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g0 g1) (disj₂ g0 (disj g1)))
    ((disj g0 g1 g ...) (disj₂ g0 (disj g1 g ...)))))

;; Then, substitute through, and specialize away

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj₂ g0 (conj g1 g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj₂ g0 (disj g1 g ...)))))

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj (disj₂ g0 g1) g ...))))

** Then we substitute through the definition of disj2/conj2, and see what happens there.

* Fresh reimplementation, janky.

Then there’s this janky reimplementation of ~fresh~. It’s hacky and
non-portable. That ~procedure-arity~ is very implementation specific
and only partially works (case-lambda, procedure-arity doesn’t really
always work, etc, see failed SRFI discussion), and at least Racket’s
~assert~ mechanism is not the same as the Scheme error handling
mechanism. But ~build-list~ is AFAIK Racket only.

#+begin_src racket
  #lang racket

  (define (fresh f)
	(let ((n (procedure-arity f)))
	  (assert (number? n))
	  (λ (s/c)
		(let ((c (cdr s/c)))
		  ((apply f (build-list n (curry + c)))
		   (cons (car s/c) (+ n c)))))))
#+end_src
