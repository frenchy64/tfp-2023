* Point of the derivation in this paper is:

* With the macro based variants, we end up building heavily nested lambdas.

The “naturally-recursive” macro-based implementations we came up with
go the wrong direction. They nest the goals unfortunately, in ways
that we can see in Redex.

** Show how using var-args for functions points the way to the correct definitions

We should be able to _see_ from the derivation how a clean definition
brings us to right behavior.

** Just switching to var-args functions isn’t enough!

Just working with var-args functions isn’t enough; we could define the
logic operators associating the “right way” just as easily as defining
them the “wrong way”. So we need some more subtle categorization.

* ~conda~

It seemed like ~conda~ had forced our hand into including the
zero-ary base case. If we wanted to build out of earlier primitives,
we had needed the zero-ary version for conda. Bracket that concern for
a second, and let’s otherwise say we don’t need that additional case.

* We already have this collection of *8* different obvious implementations.

We can implement the 2+-ary versions, using conj2/disj2 as primitives,
in either the tail recursive or the natl. recursive versions, with
either macros or varargs, either forwards or backwards. So that’s a
nice place to start. Note, that left or right association and left or
right fold are the same, because the operator is binary
conj2/disj2---association is fold. Selecting a starting operator
conj2 v. disj2 is not an axis of variation; any successful approach
must work for both.

* Suppose we _want_ to implement the 1+ary versions.

Why would you want to do that? Macros, for instance. The ~(C g)~ case
matters b/c, say, some ~conde~ macro, or ~fresh~ if you wanted. Maybe
it would suck if the user had to think about whether their ~fresh~
body had 1 or 2+ goals in it. But suppose you didn’t care about that,
either, and that you didn’t need the singleton conjunction case
either. Then we can pick from a smörgåsbord of options.

** We derivation our “clean” version from one of these short recursive variants.

So, which one is this?---~varargs-2+-left-assoc~

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(cond
	  ((null? gs) ((conj2 g1 g2) s))
	  (else ((apply C (cons (conj2 g1 g2) gs)) s))))
#+end_src

We can start by breaking the function up into a recursive variant and
an external-facing help function:

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g1 g2 gs s))

  (define (C-rec g1 g2 gs s)
	(cond
	  ((null? gs) ((conj2 g1 g2) s))
	  (else
	   (C-rec (conj2 g1 g2) (car gs) (cdr gs) s))))
#+end_src

If we substitute through in the definition of ~conj2~, we get:

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g1 g2 gs s))

  (define (C-rec g1 g2 gs s)
	(cond
	  ((null? gs) ((lambda (s) ($append-map g2 (g1 s))) s))
	  (else
	   (C-rec (lambda (s) ($append-map g2 (g1 s))) (car gs) (cdr gs) s))))
#+end_src

Here is the important piece; since we only need ~s~ to *build the
stream*, we can assemble the stream on the way /in/, and accumulate
along it---instead of passing in g1 and s separately, we pass in their
combination as a stream. The function is tail recursive, we can change
the signature in the one and only external call and the recursive
call.

We had to combine and hand substitute through, as in ~((lambda (s)
($append-map g2 (g1 s))) s)~

#+begin_src racket
  #lang racket
  (define ((C g1 g2 . gs) s)
	(C-rec g2 gs (g1 s)))

  (define (C-rec g2 gs s-inf)
	(cond
	  ((null? gs) ($append-map g2 s-inf))
	  (else (C-rec (car gs) (cdr gs) ($append-map g2 s-inf)))))
#+end_src

Now, we can turn this into a 1+ary version; the recursion and the
base case share a lot in common, and we can exploit that: pass back
the stream in the base case, and split ~gs~ in the other case.

#+begin_src racket
  #lang racket
  (define ((C g1 . gs) s)
	(C-rec gs (g1 s)))

  (define (C-rec gs s-inf)
	(cond
	  ((null? gs) s-inf)
	  (else (C-rec (cdr gs) ($append-map (car gs) s-inf)))))
#+end_src

And there you have it. We can derive this answer _from_ the original
version. Both the first version and this final version have their
virtues and drawbacks; one uses explicit ~car~ and ~cdr~, while the
other uses apply. I think we prefer this last one, because it’s
strictly more general.

This “derivation sequence” is essentially a three step operation: 1.
take an operation based on conj2/disj2 and then go beneath that
level 2. some simple clean-up optimizations 3. reduce the demanded
arity so that it operates on 1+ arguments.

It could be nice to avoid having to specialize our macros to the two
different cases and keep our users from needing to worry adding and
removing a combinator when moving from one to more than one goal.

#+begin_src racket
	#lang racket

	(define-syntax fresh
	  (syntax-rules ()
		[(fresh () g) <do something on this one>]
		[(fresh () g g1 g* ...) <do something on this one>]
		[(fresh (x ...) g ...) <recur here down to base case>]))
#+end_src

To illustrate just how superfluous the 0-arity version is, we can
always add that as a separate case in the interface function.

#+begin_src racket
  #lang racket
  (define ((C . gs) s)
	(cond
	  ((null? gs) S)
	  (else (C-rec (cdr gs) ((car gs) s)))))

  (define (C-rec gs s-inf)
	(cond
	  ((null? gs) s-inf)
	  (else (C-rec (cdr gs) ($append-map (car gs) s-inf)))))
#+end_src

** So. Can we do the same thing for *all* of those variants?

Is this transformation sequence equally applicable across all of the 4
versions? Or some analogous version of it?

To recapitulate, our initial motivation was to remove some macros.
This led to using variadic functions to combine arbitrary-length goal
sequences. I want to tell a story where many, if not all, of the
decisions fell out as a consequence of this choice.


Well come to think of it, if we just exclude the vestigial runt base
case, we could let var args do the pattern matching for us.

#+begin_src racket
  #lang racket
  (define ((C g g1 . gs) s)
  (cond
    ((null? gs) (append-map g (g1 s)))
    (else (append-map g ((apply C (cons g1 gs)) s)))))

#+end_src

Which is to say

#+begin_src racket
#lang racket
  (define ((conj2 g g1) s)
	(append-map g (g1 s)))

  (define ((C g g1 . gs) s)
	(cond
	  ((null? gs) ((conj2 g g1) s))
	  (else ((conj2 g (apply C (cons g1 gs))) s))))
#+end_src

And that works. We could have in the recursion associated it the other way

#+begin_src racket
  #lang racket

  (define ((C g g1 . gs) s)
  (cond
	((null? gs) ((conj2 g g1) s))
	(else ((apply C (cons (conj2 g g1) gs)) s))))

#+end_src
What about in the version before that?

#+begin_src racket
  #lang racket
  ;; ne-listof goals -> s -> $tr
(define ((C g . gs) s)
  (cond
    ((null? gs) (g s))
    (else (append-map g ((apply C gs) s)))))


(define ((C g₁ . gs) s)
  (C-rec (g₁ s) gs))

(define (C-rec s∞ gs)
  (cond
    ((null? gs) s∞)
    (else
      (C-rec (append-map (car gs) s∞) (cdr gs)))))


#+end_src

It would be unfortunate to mandate

This list of goals then needed to be processed one at a
time and build a resulting stream of answers.


#+begin_src racket
  #lang racket
  (define ((D . gs) s)
  (cond
    ((null? gs) (list s))
    (else (g s))))


#+end_src

1. I mean, honestly. That 0-ary base case needs to go. We gotta get rid of that.
2. To get rid of macro, start with 2-ary versions. These blend easily.
1. To avoid the macro
2. need variadic functions and recursively process arg list.
: oughnt't introduce artificial extra goals in base case.
: oughtn't need artificial base cases
: need to come in with an initial value for the accumulator
: so need to demand at least one goal to start with


(define-syntax conj
  (syntax-rules ()
    ((conj) S)
    ((conj g) g)
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))


;; wasted disj attempt


(define ((D . gs) s)
  ...)

Since \rackinline|gs| could be empty, as with the macro based
implementation we introduce a base-case for the zero-length list.

(define ((D . gs) s)
  (cond
    ((null? gs) (list))
    ...))

But it's also unfortunate to force an extra failing recursion onto every call,
so we add the length-one arguments list to short-circuit that.

(define ((D . gs) s)
  (cond
    ((null? gs) '())
    ((null? (cdr gs)) (g s))
    ...))

;; These assume 2+ goals; and we don’t write or work w/ “silly conjunctions.”

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj (disj₂ g0 g1) g ...))))

;; These next two are from the paper, as written.
;; As they’re written, they are 0-or-more-ary.
;; But they likewise shouldn’t require silly arities.

(define-syntax conj
  (syntax-rules ()
    ((conj) S)
    ((conj g) g)
    ((conj g0 g ...) (conj₂ g0 (conj g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj) F)
    ((disj g) g)
    ((disj g0 g ...) (disj₂ g0 (disj g ...)))))

;; So we first remove the zero arity, conda be damned.

(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g0 g ...) (conj₂ g0 (conj g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g0 g ...) (disj₂ g0 (disj g ...)))))

;; Then, we try again and unfold the recursion once more

(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g0 g1) (conj₂ g0 (conj g1)))
    ((conj g0 g1 g ...) (conj₂ g0 (conj g1 g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g0 g1) (disj₂ g0 (disj g1)))
    ((disj g0 g1 g ...) (disj₂ g0 (disj g1 g ...)))))

;; Then, substitute through, and specialize away

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj₂ g0 (conj g1 g ...)))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj₂ g0 (disj g1 g ...)))))

(define-syntax conj
  (syntax-rules ()
    ((conj g0 g1) (conj₂ g0 g1))
    ((conj g0 g1 g ...) (conj (conj₂ g0 g1) g ...))))

(define-syntax disj
  (syntax-rules ()
    ((disj g0 g1) (disj₂ g0 g1))
    ((disj g0 g1 g ...) (disj (disj₂ g0 g1) g ...))))

** Then we substitute through the definition of disj2/conj2, and see what happens there.

* Fresh reimplementation, janky.

Then there’s this janky reimplementation of ~fresh~. It’s hacky and
non-portable. That ~procedure-arity~ is very implementation specific
and only partially works (case-lambda, procedure-arity doesn’t really
always work, etc, see failed SRFI discussion), and at least Racket’s
~assert~ mechanism is not the same as the Scheme error handling
mechanism. But ~build-list~ is AFAIK Racket only.

#+begin_src racket
  #lang racket

  (define (fresh f)
	(let ((n (procedure-arity f)))
	  (assert (number? n))
	  (λ (s/c)
		(let ((c (cdr s/c)))
		  ((apply f (build-list n (curry + c)))
		   (cons (car s/c) (+ n c)))))))
#+end_src
