\documentclass[sigplan,screen,draft,anonymous,review,natbib=false]{acmart}
%% ∞
%% …
%% ₀
%% ₁
%% ₂
%% ₃
\usepackage{fontspec,newunicodechar}
\usepackage{hyphenat} %% electromagnetic\hyp{}endioscopy
\usepackage[shortcuts]{extdash}
\usepackage{microtype} %% provides tighter text formatting
\usepackage{polyglossia} %% for xelatex use polyglossia, needed for csquotes
\setdefaultlanguage[variant=american]{english}

\PassOptionsToPackage{cache=false,newfloat=true}{minted}
\PassOptionsToPackage{unicode}{hyperref}

\usepackage[capitalize,nameinlink]{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\RequirePackage[
  datamodel=acmdatamodel,
  style=acmnumeric,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{mkw.bib}

\usepackage{nag} %% should complain about old and outdated commands
\usepackage{minted}
\usepackage[strict,autostyle]{csquotes} %% enquote &c that doesn't interfere w/cdlatex usage
%% http://ftp.lyx.org/pub/tex-archive/macros/latex/contrib/csquotes/csquotes.pdf
%% \usepackage[xspace]{ellipsis} they suggest using xetex instead
%% \usepackage{setspace} %% set the spacing (single double, etc)

\setmonofont{DejaVuSansMono}[Scale=MatchLowercase]
\tracinglostchars=2
\usepackage[defaultlines=3,all]{nowidow} %% Eliminates widow and orphans
\usepackage{todonotes}

\newmintinline[rackinline]{racket}{}
\newmintinline{prolog}{}

\setcopyright{acmcopyright}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{XXXXXXX.XXXXXXX}


\acmConference[mKW '22]{miniKanren Workshop}{September 15,
  2022}{Ljubljana, Slovenia}

\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}



\begin{document}

\title[Some criteria for implementations of conj and disj in
microKanren]{Some criteria for implementations of conjunction and
  disjunction in microKanren}

\author{Jason Hemann}
\email{jhemann@northeastern.edu}
\orcid{1234-5678-9012}
\author{Daniel P. Friedman}
\email{dfried@cs.indiana.edu}
\orcid{1234-5678-9012}

\renewcommand{\shortauthors}{Hemann et al.}

\begin{abstract}
  We describe here how, at the cost of an additional language
  feature---namely variadic, \enquote{rest argument} functions---we
  can implement a slightly higher-level kernel language. We implement
  conjunction and disjunction functions that preserve search order and
  that do not create superfluous closures. The result is a shorter and
  simpler overall implementation that is more elegant.
\end{abstract}

\keywords{}

\maketitle

\section{Introduction}

microKanren~\cite{hemann2013muKanren} is a compact approach to
implementing a relational programming language. The microKanren
approach has worked out well as a tool for understanding the guts of a
relational programming language through studying its implementation.
The microKanren reimplementation separates surface syntax macros from
function definitions. In doing so, the authors hoped this separation
would simultaneously aid future would-be implementers when studying
the source code, and also that the functional core would make the
language easier to port to other functional hosts. To support both
those efforts, they also chose to program in a deliberately small and
workaday set of Scheme primitives.

This note shows how an implementer using a host language with variadic
(any number of arguments) functions can build a somewhat more powerful
kernel language and obviate macros for conjunction and disjunction.
Until now there was a large gap between those microKanren
implementations in languages with expressive macro systems and those
without; variadic functions permit an intermediate point in the
language design space. Even implementers in languages \emph{with}
 macro systems might choose to replace existing less
powerful language primitives by our comparatively short but more
powerful variants. Beyond that, this more powerful kernel language
obviates several macros in the desugaring layer, and eventually leads
us to see merit in modifying the core language's syntax. This is, of
course, subjective.

Beyond being a conceptually simpler foundation for a full Kanren
language at the level of \citetitle{friedman2018reasoned}, this
implementation appears to be more \emph{efficient}. Right-associative
conjunction is already conjectured in miniKanren implementation
folklore to be an inefficient design choice. We were pleasantly
surprised that thinking about the expressivity of primitives and code
improvement \enquote{horse sense} led us to this same idea. That very
horse sense might lead one to suggest these improved variants should
actually be the external programming constructs. This, too, is very
speculative.

In \cref{sec:all-aboard}, we briefly revisit microKanren
implementations and illustrate why surface syntax macros had seemed
practically mandatory. In~\cref{sec:conde}, we implement conjunction
and disjunction, and in \cref{sec:impure} we discuss the
re-implementation of the impure operators. We close with a discussion
of some performance impacts of these implementation choices, and
consider how Kanren language implementers outside of the Scheme family
might benefit from these alternative implementations.

\section{All Aboard!}\label{sec:all-aboard}

We assume the reader is familiar with the miniKanren language as
described in \citetitle{friedman2018reasoned} and in particular with
microKanren implementations. See \href{minikanren.org}{minikanren.org}
for many implementations across multiple host languages.

The world's shortest subway system is Haifa's Carmelit, with only
six stations. The system is a line, so its trains travel back and
forth. If we wanted to describe the order in which we rode the train
from the beginning to the end, we could use the
\rackinline|carmelit-subway| relation in~\cref{mnt:carmelit}. We
express this relation using the more compact miniKanren syntax because
unfolding this relation into binary conjunctions and disjunctions
would be painful. We certainly \emph{could} write it out by hand---in
fact, we could write it out many ways. We could nest those
conjunctions to the left, or to the right, or try and reduce the
indentation by trying to keep them somewhat balanced: the program
itself does not seem to obviously encourage one particular choice.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (conde
    ((== a 'carmel-center)
     (== b 'golomb)
     (== c 'masada)
     (== d 'haneviim)
     (== e 'hadar-city-hall)
     (== f 'downtown))
    ((== a 'downtown)
     (== b 'hadar-city-hall)
     (== c 'haneviim)
     (== d 'masada)
     (== e 'golomb)
     (== f 'carmel-center))))
  \end{minted}
  \caption{A miniKanren implementation of the Carmelit subway.}
  \label{mnt:carmelit}
\end{listing}

In a microKanren in a macro-less host language, a programmer could get
bothered by low-level details such as stacking binary conjunction and
disjunction. A small programming mistake, such as incorrectly nesting
a conjunct somewhere in a long conjunction chain, can cause relatively
obscure errors and reading those error messages forces the programmer
away from DSL-level thinking, and back into the host programming
language's debug model.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conde
  (syntax-rules ()
    ((conde (g ...) ...)
     (disj (conj g ...) ...))))

(define-syntax conj
  (syntax-rules ()
    ((conj) #s)
    ((conj g) g)
    ((conj g₀ g ...) (conj₂ g₀ (conj g ...)))))

(define ((conj₂ g₁ g₂) s)
  (append-map∞ g₂ (g₁ s)))

(define-syntax disj
  (syntax-rules ()
    ((disj) #u)
    ((disj g) g)
    ((disj g₀ g ...) (disj₂ g₀ (disj g ...)))))

(define ((disj₂ g₁ g₂) s)
  (append∞ (g₁ s) (g₂ s)))
  \end{minted}
  \caption{Macro based implementations of \rackinline|conj| and \rackinline|disj|.}
  \label{mnt:conj-and-disj-implementation}
\end{listing}

\Cref{mnt:conj-and-disj-implementation} shows typical macro-based
implementations of \rackinline|conde| and the underlying conjunction
and disjunction operations. Here, \rackinline|#s| and \rackinline|#u|
represent primitive goals that unconditionally succeed and fail,
respectively.

\section{\rackinline|conj| and \rackinline|disj| logical goal
  constructors}\label{sec:conde}

The \rackinline|conj| and \rackinline|disj| macros of
~\cref{mnt:conj-and-disj-implementation} are not \emph{quite} defined
as simple recursions over their binary functional primitives. The
definition of 0-way conjunction (disjunction) is independent of the
unfolding of \rackinline|conj₂| (\rackinline|disj₂|). In a sense the
\rackinline|conj| and \rackinline|disj| macros confuse and entangle
primitive success and failure goals with those recursive unfoldings in
terms of the binary operators.

Those zero-way logical operation base cases don't add much. The
programmer who tries to write an elegant, efficient solution to a pure
relational programming task would not encounter these additional base
cases in his \rackinline|conde| expressions. The programmer knows
statically how such goals should behave, so there is no benefit to
executing them. A conjunction of no goals would simply succeed, and a
disjunction of no goals would simply fail. Truthfully, only the impure
\rackinline|conda| operator seems to require these additional base
cases (discussed further in~\cref{sec:impure}) they are for all
intents and purposes superfluous.

Here, we want to implement conjunction and disjunction over
one-or-more goals as functions. These implementations will rely on
variadic function syntax, but should not require \rackinline|apply| or
rely on the binary \rackinline|conj₂| and \rackinline|disj₂|. Further,
they should not build any extraneous closures: unnecessarily building
closures at runtime is always a bad idea.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (D g gs s))

  (define (D g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (append∞ (g s)
         (D (car gs) (cdr gs) s)))))
  \end{minted}
  \caption{Re-implementation of \rackinline|disj|.}
  \label{mnt:disj-reimplementation}
\end{listing}

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (C (cdr gs)
          (append-map∞ (car gs) s∞)))))
  \end{minted}
  \caption{Re-implementation of \rackinline|conj|.}
  \label{mnt:conj-reimplementation}
\end{listing}

\Cref{mnt:disj-reimplementation,mnt:conj-reimplementation} show our new
implementations. Mandating one-or-more arguments lets us re-implement
these operators as shallow wrappers over simple folds. The first step
in each is merely to remove the rest argument \rackinline|gs| and act
as if there were no need for a rest argument. That is, all of our
focus will be on the \emph{list}, \rackinline|gs|. The function
\rackinline|C| does not take in the state \rackinline|s|; the help
procedure does not need the state for conjunction. In each recursive
call, we accumulate by mapping (using the special delaying
implementation of append-map for miniKanren streams) the next goal in
the list. This left-fold implementation of conjunction therefore
left-associates the conjuncts.

\subsection{Implementation correctness}

Equipped with variadic functions, a developer might discover these
definitions as follows. We start with the definition of
\rackinline|disj| from \cref{mnt:disj-function-before-derivation}. At
the cost of an \rackinline|apply|, we can define \rackinline|disj| as
a single explicitly recursive function.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g₀ g₁ g ...) (disj₂ g₀ (disj g₁ g ...)))))

  (define (disj g . gs)
    (cond
      ((null? gs) g)
      (else (disj₂ g (apply disj gs)))))
\end{minted}
  \caption{\rackinline|disj₂|-based macro and function definition.}
  \label{mnt:disj-function-before-derivation}
\end{listing}

\noindent Since \rackinline|disj| produces and consumes goals, we can
η expand the definition by a curried parameter \rackinline|s|. We also
split \rackinline|disj| into two mutually-recursive procedures.

\begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (D g gs s))

  (define (D g gs s)
    (cond
      ((null? gs) (g s))
      (else ((disj₂ g (apply disj gs)) s))))
\end{minted}

\noindent We can replace the call to \rackinline|disj₂| by its
definition in terms of \rackinline|append∞| and perform a trivial
β-reduction. The explicit \rackinline|s| argument suggests making
\rackinline|D| recur into itself. The result is the definition
in~\cref{mnt:disj-reimplementation}.

We can derive the definition of \rackinline|conj| from
\cref{mnt:conj-reimplementation} via a similar process. Starting with
the variadic function definition
of~\cref{mnt:conj-function-derived-definition}, we first η-expand and
split the definition.

\begin{listing}
\begin{minted}[autogobble,stripall]{racket}
  (define-syntax conj
    (syntax-rules ()
      ((conj g) g)
      ((conj g g₁ gs ...)
       (conj (conj₂ g g₁) gs ...))))

  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else
       (apply conj
         (cons (conj₂ g (car gs)) (cdr gs))))))
\end{minted}
  \caption{\rackinline|conj₂|-based \rackinline|conj| function and macro.}
  \label{mnt:conj-function-derived-definition}
\end{listing}

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       ((apply conj
          (cons (conj₂ g (car gs)) (cdr gs)))
        s))))
\end{minted}

\noindent We will substitute the definitions of \rackinline|conj| and
\rackinline|conj₂|.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (C (λ (s) (append-map∞ (car gs) (g s)))
          (cdr gs)
          s))))
\end{minted}

Finally, since \rackinline|C| only needs \rackinline|s| to
\emph{build} the stream, we can assemble the stream on the way
in---instead of passing in \rackinline|g| and \rackinline|s|
separately, we pass in their combination as a stream. The function is
tail recursive, we can change the signature in the one and only
external call and the recursive call. We show the result
in~\cref{mnt:conj-reimplementation}.

Both the variadic function based and the macro based versions of
\cref{mnt:conj-function-derived-definition} use a left fold over the
goals, whereas the versions of \rackinline|disj| use a right fold.
This is not an accident. It is miniKanren folklore that left
associating conjunctions tends to improve miniKanren performance. A
full, thorough, explanation of what we know about this behavior is
outside the scope of our work here, but see discussions by
Rosenblatt~\cite{nowhere} and Ballantyne~\cite{nowhere}. The matter
seems so significant that the community might consider reclassifying
left-associative conjunction as a matter of correctness rather than an
optimization, as in \enquote{tail call optimization} vs.
\enquote{Properly Implemented Tail Call
  Handling}~\cite{felleisen2014requestions}. However, we have
generally resorted to small step visualizations of the search tree to
demonstrate why that might be. The authors believe it is \emph{worth
  further consideration} if we can make an equally compelling argument
for this preference through equational reasoning.
\Cref{mnt:conj-right-fold-definition} shows a right-fold variant of
\rackinline|conj|. The choice to fold left becomes a little more
obvious after we η-expand, unfold to a recursive help function,
substitute in the definition of \rackinline|conj₂|, and β-reduce.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else (conj₂ g (apply conj gs)))))
\end{minted}
  \caption{A right-fold variant of \rackinline|conj|.}
  \label{mnt:conj-right-fold-definition}
\end{listing}

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else (append-map-∞ (apply C gs) (g s)))))
\end{minted}

\noindent Here, we cannot (easily) replace the \rackinline|apply| call
by a recursive call to \rackinline|C|, because we are still waiting
for an \rackinline|s|. We can only abstract over \rackinline|s| and
wait.

\begin{minted}[autogobble,stripall]{racket}
  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (append-map∞
         (λ (s) (C (cdr gs) ((car gs) s)))
         s∞))))
\end{minted}

Since we know that any call to \rackinline|append-map∞| we construct
will always yield a result, the version in
\cref{mnt:conj-reimplementation} is tail recursive. The equivalent
right-fold implementation needs to construct a closure for every
recursive call. If we want to implement a variadic version that does
not rely on a primitive \rackinline|conj2| and does not resort to
\rackinline|apply|, we have the two aformentioned choices. Basic
programming horse sense suggests the variant from
\cref{mnt:conj-reimplementation}.

Though this note mainly concerns the choice to implement surface
language behavior as functions, it may also point to these as more
natural user-level primitives than \rackinline|conde|. An
implementation could choose to forego \rackinline|conde| and provide
just those underlying logical primitives \rackinline|conj| and
\rackinline|disj| to the user.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (disj
   (conj (== a 'carmel-center)
         (== b 'golomb)
         (== c 'masada)
         (== d 'haneviim)
         (== e 'hadar-city-hall)
         (== f 'downtown))
   (conj (== a 'downtown)
         (== b 'hadar-city-hall)
         (== c 'haneviim)
         (== d 'masada)
         (== e 'golomb)
         (== f 'carmel-center))))
  \end{minted}
  \caption{A reimplemented Carmelit subway without \rackinline|conde|.}
  \label{mnt:new-carmelit}
\end{listing}

\section{Cleaning up the Impure Operators}\label{sec:impure}

Some programmers would be perfectly satisfied to have lived forever
with \rackinline|ifte| itself. But just as the standard forked
\rackinline|if| begat McCarthy's \rackinline|if| notation and
\rackinline|cond|, we can suspect that a programmer would eventually
feel the need for a nested implementation.

The operators \rackinline|conda| and \rackinline|conde| look
superficially similar, syntactically. Semantically though, the
disjunction and nested \enquote{if-then-else} behaviors are quite
different, and implementing the desired behavior for this
\rackinline|conda| from existing pieces raises some oddities. The
definition of \rackinline|conda| (see \cref{mnt:conda-implementation})
rules out zero-way conjunctions of goals in the clause body as well as
zero-way disjunctions of such clauses. A \rackinline|conda| that
permits one-or-more-goals in each clause is the one and only place in
the whole langauge implementation that may require a nullary
conjunction of goals. So this soft-cut operator seems to force both
nullary conjunction and those primitive goals \rackinline|#s| and
\rackinline|#u| into the language.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g₀ g ...)) (conj g₀ g ...))
    ((conda (g₀ g ...) ln ...)
     (ifte g₀ (conj g ...) (conda ln ...)))))

(define ((ifte g₁ g₂ g₃) s)
  (let loop ((s∞ (g₁ s)))
    (cond
      ((null? s∞) (g₃ s))
      ((pair? s∞)
       (append-map g₂ s∞))
      (else (lambda ()
              (loop (s∞)))))))
  \end{minted}
  \caption{A typical implementation of \rackinline|conda|.}
  \label{mnt:conda-implementation}
\end{listing}

There are alternative choices one could consider.

\begin{enumerate}

\item Syntactically mandate that all clauses in \rackinline|conda|
  contain at least two goals.

\item Syntactically mandate that all clauses \emph{except the final
    default clause} contain at least two goals.

\item Introduce a special clause of the \rackinline|conda| macro
  specifically for \enquote{if then} clauses with a single goal.

\item Unconditionally add an a \rackinline|#s| goal to each clause
  during macro expansion.

\end{enumerate}

All these choices, however, implicitly or explicitly can force
additional unneeded executions of unwanted goals. Here too, removing
macros and relying on variable arity function definition provides a
more elegant solution.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define ((conda q a . q-and-a*) s)
  (A (q s) a q-and-a* s))

(define (A s∞ a q-and-a* s)
  (cond
    ((null? s∞)
     (cond
       ((null? (cdr q-and-a*)) ((car q-and-a*) s))
       (else (A ((car q-and-a*) s)
                    (cadr q-and-a*)
                    (cddr q-and-a*) s))))
    ((pair? s∞) (append-map∞ a s∞))
    (else (lambda () (A (s∞) a q-and-a* s)))))
  \end{minted}
  \caption{A functional \rackinline|conda| implementation.}
  \label{mnt:conda-good-re-implementation}
\end{listing}

The implementation in~\cref{mnt:conda-bad-re-implementation} includes
the delay-and-restart behavior of \rackinline|ifte| together with
\rackinline|conda|'s logical cascade.

\subsection{\rackinline|condu|}

We have not yet addressed~\rackinline|condu|. We could implement this
for functional programmers with a variant
of~\cref{mnt:conda-bad-re-implementation}. Instead, we choose to make
\rackinline|once| a primitive higher-order goal. This relies on a
local \rackinline|let|-bound named recursive procedure.

\begin{listing}
  \begin{minted}[autogobble,stripall]
    {racket}
(define (once g)
  (lambda (s)
    (let loop ((s∞ (g s)))
      (cond
        ((null? s∞) '())
        ((pair? s∞)
         (cons (car s∞) '()))
        (else (lambda ()
                (loop (s∞))))))))
  \end{minted}
  \caption{A functional \rackinline|once| implementation.}
  \label{mnt:condu-bad-re-implementation}
\end{listing}

\section{Conclusion}\label{sec:conclusion}

narrows the gap between implementations in functional host languages
with and without macro systems.

More languages than ever before support variable arity
functions/methods (aka \verb|varargs| aka \verb|slurpy| methods),
including Raku, Java, and Ruby, to name just a few. Many of these
languages also support polyvariadic functions. The authors hope that
this document helps implementers build more elegant, expressive and
efficient Kanrens in their chosen host languages.

Languages with variadic but without polyvariadic (that is to say
\enquote{at least $k$ arguments}) functions---how do they fare here?

This is closer to the design of Prolog,
where the user represents conjuction of goals in the body of a clause
with a comma and disjunction, either implicitly in listing various
clauses or explicitly with a semicolon.

Languages without expressive macro systems would still have to resort
to exposing implementations of streams and \emph{some} lower level
operations like introducing variables one at a time. But!

We take it as granted that conjunction and disjunction themselves are
sufficiently high-level operators for a surface language and that the
0-element base cases are at best unnecessary and likely undesireable.

Given the opportunity to define a surface language and its desugaring,
we really shouldn't tempt the programmer by making undesireable
programs representable when we can avoid doing so.

Of course, no implementer \emph{needs} a macro system to implement a
shallow embedding of an LP language. In our implementations, we still
use macros to implement \rackinline|defrel| and \rackinline|fresh|,
the former to prevent exposing the implementation of streams and
delays, and the latter both for the added efficiency and to avoid the
awkwardness of introducing each variable one at a time.

From time to time we find that the usual miniKanren implementation is
itself lower-level than we would like to program with relations.
Expert miniKanren programmers use macros to extend the language yet
again, as with \rackinline|matche|, and also with wholly more
expressive and highly optimized language forms, as in the original
\rackinline|Kanren|. It is nice to find we can spread some of that
extra expressiveness to the wider Kanren language community.

Even implementers using and programmers studying implementations
written in languages \emph{with} sufficiently expressive macro systems
can benefit from these improvements. There are benefits to using a
limited set of features in a language. Based on an evaluation
of~\href{minikanren.org}{minikanren.org}, earlier microKanren
implementers measured their results by the number of lines in the core
implementation, the number of additional lines for the surface syntax,
and the limited features they required from the host. So replacing

Early microKanren implementations restrict themselves to
\rackinline|syntax-rules| macros. Several more powerful syntax
constructions over miniKanren may rely on more expressive macro
systems, including Ballantyne's
\rackinline|minikanren-ee|~\cite{ballantyne2020macros}.

This note shows that at the cost of one additional feature--namely
variadic functions---implementers provide a somewhat more powerful
core language and significantly reduce the need for macros in
implementing a language as expressive as the full
\verb|microKanren + Macros| approach provides.

Our desugaring macros would have worked whether we left or right
associated. Removing a degree of freedom in the implementation, and
forcing ourselves to program the solution functionally, led us to what
seems like the right solution.

\begin{acks}

  Thanks also to Ken Shan and Jeremy Siek, for helpful discussions and
  debates during design decision deliberations. Greg Rosenblatt for
  his discussion later

\end{acks}

\printbibliography{}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
