\documentclass[sigplan,draft,balance,pbalance,natbib=false]{acmart}
%% ∞
%% …
%% ₀
%% ₁
%% ₂
%% ₃
\usepackage{fontspec,newunicodechar}
\usepackage{hyphenat} %% electromagnetic\hyp{}endioscopy
\usepackage[shortcuts]{extdash}
\usepackage{microtype} %% provides tighter text formatting
\usepackage{flushend}
\usepackage{balance}
\usepackage{polyglossia} %% for xelatex use polyglossia, needed for csquotes
\setdefaultlanguage[variant=american]{english}

\PassOptionsToPackage{cache=false,newfloat=true}{minted}
\PassOptionsToPackage{unicode}{hyperref}

\usepackage[capitalize,nameinlink]{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\RequirePackage[
  datamodel=acmdatamodel,
%%  style=acmnumeric,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{mkw.bib}

\overfullrule=0pt

%\usepackage{nag} %% should complain about old and outdated commands
\usepackage{minted}
\usepackage[strict,autostyle]{csquotes} %% enquote &c that doesn't interfere w/cdlatex usage
%% http://ftp.lyx.org/pub/tex-archive/macros/latex/contrib/csquotes/csquotes.pdf
%% \usepackage[xspace]{ellipsis} they suggest using xetex instead
%% \usepackage{setspace} %% set the spacing (single double, etc)

\setmonofont{DejaVuSansMono}[Scale=MatchLowercase]
\tracinglostchars=2
\usepackage[defaultlines=3,all]{nowidow} %% Eliminates widow and orphans
\setlength {\marginparwidth }{2cm}
\usepackage{todonotes}

\newmintinline[rackinline]{racket}{}
\newmintinline{prolog}{}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TFP '23]{Symposium on Trends in Functional
  Programming}{January 13-15, 2023}{Boston, Massachusetts}

\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}

\begin{document}

\title{Nearly Macro-free microKanren}

\author{Jason Hemann}
\email{jason.hemann@shu.edu}
\orcid{0000-0002-5405-2936}
\author{Daniel P. Friedman}
\email{dfried@cs.indiana.edu}
\orcid{0000-0001-9992-1675}

\renewcommand{\shortauthors}{Hemann et al.}

\begin{abstract}

  This paper describes changes to the microKanren implementation to
  broaden the kinds of platforms it may be embedded in. We lift
  microKanren's macro-support requirement for host platforms, trading
  it for modest runtime features common to most languages. The
  resulting implementation is smaller, simpler, and relevant even to
  implementers that enjoy macro support. For those without it, we
  address some practical concerns that necessarily occur without
  macros so they can better weigh their options.

\end{abstract}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011015</concept_id>
       <concept_desc>Software and its engineering~Constraint and logic languages</concept_desc>
       <concept_significance>500</concept_significance>
   </concept>
   <concept>
       <concept_id>10003752.10003790.10003795</concept_id>
       <concept_desc>Theory of computation~Constraint and logic programming</concept_desc>
       <concept_significance>300</concept_significance>
   </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Constraint and logic languages}
\ccsdesc[500]{Software and its engineering~Automatic programming}

%%
 %% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{logic programming, miniKanren, DSLs, embedding, macros}

\maketitle

\section{Introduction}

The authors designed microKanren~\cite{hemann2013muKanren} as a
compact relational programming language kernel to undergird a
miniKanren implementation. The surface miniKanren syntax and
higher-level operators are implemented as macros.\@ microKanren is
often used as a tool for understanding the guts of a relational
programming language through studying its implementation. By
re-implementing miniKanren as separate surface syntax macros over a
purely-function microKanren kernel, the authors hoped this separation
would simultaneously aid implementers when studying the source code,
and also that the functional core would make the language easier to
port to other functional hosts. To support both those efforts, they
also chose to program in a deliberately small and workaday set of
Scheme primitives.

The sum of those implementation choices restricted the design space to
necessitate somewhat awkward compromises in several places including
binary logical operators, one at a time local variable introduction,
and leaks in the streams abstractions. This left the surface syntax
macros seem practically mandatory, and so divided host languages into
the macro language \enquote{haves} and the macro-less \enquote{have
  nots}. Here, we bridge some of that divide by re-implementing parts
of the kernel with some modest runtime features common to most
languages.

In this paper we:
%
\begin{itemize}

\item show how to functionally implement more general logical
  operators, cleanly obviating some of the surface macros

\item provide guidance and utilitarian solutions for eliminating all
  other macros in the \emph{TRS2e} microKanren implementation

\item survey the purely functional design space, and weigh the trade
  offs and real-world concerns of completely eliminating those
  remaining macros.

\end{itemize}

This exercise resulted in some higher-level (variadic rather than just
binary) operators, a more succinct kernel language, and made possible
some performance improvement. Approximately half of the changes are
applicable to any microKanren implementation, and the other half are
necessarily awkward yet practical strategies for platforms lacking
macro support. The source code for both our re-implementation and
experimental results is available
at~\url{https://github.com/jasonhemann/tfp-2023/}.

In \cref{sec:all-aboard}, we illustrate by example what made surface
syntax macros feel practically mandatory. In \cref{sec:conde}, we
implement conjunction and disjunction, and in \cref{sec:impure} we
discuss the re-implementation of the impure operators. We discuss the
remaining macros in \cref{sec:functional}. We close some outstanding
questions on performance impacts of these implementation choices, and
consider how Kanren language implementers outside of the Scheme family
might benefit from these alternatives.

\section{All Aboard!}\label{sec:all-aboard}

We assume the reader is familiar with the microKanren-based miniKanren
implementation of \emph{The Reasoned Schemer, 2nd Ed}
(\emph{TRS2e})~\cite{friedman2018reasoned}. In addition, at places we
make occasional references to earlier iterations such as
\citeauthor{hemann2016small}~\cite{hemann2016small}, an expanded
archival version of the 2013 paper~\cite{hemann2013muKanren}.

Haifa's Carmelit is the world's shortest subway system with a line of
just six stations; a sufficiently small example. But in microKanren,
to model the order a passenger visit the stops riding the subway end
to end requires 11 logical operator nodes, because microKanren only
provides \emph{binary} conjunctions and disjunctions.
(\Cref{mnt:new-carmelit} contains this paper's alternative solution,
requiring just three.) For a logic programming language, only binary
logical operators is too low level. To our eyes, this makes the
superficial syntax macros are practically mandatory, and host
languages without a macro system are out of luck.

The microKanren language doesn't offer the programmer much guidance in
using that fine-grained control. For a series of $n$ goals, the
programmer can associate them to the left, to the right, or some
mixtures of the two. The language itself does not seem to obviously
encourage one particular choice.

The \emph{TRS2e} microKanren's soft-cut operator, \rackinline{ifte},
is similarly low level. It permits a single test, a single consequent,
and a single alternative. To build an if-then-else cascade, a
microKanren programmer without the \rackinline{conda} surface macro
would need to unroll that cascade by hand.

The \emph{TRS2e} language implementation relies on
macros \rackinline{fresh}, \rackinline{defrel}, and \rackinline{run}
to introduce new logic variables, globally define relations, and
execute queries. Earlier implementations of those same behaviors via
pure functional shallow embeddings, without macros, had some harsh
consequences. We will revisit those earlier implementations and their
trade-offs, survey the landscape of other available choices, and
suggest performant compromises for those truly without macros.

\section{\rackinline{disj} and \rackinline{conj} logical goal
  constructors}\label{sec:conde}

We want to implement disjunction and conjunction over arbitrary
quantities goals, as functions. These implementations should subsume
the binary \rackinline{disj₂} and \rackinline{conj₂} but should not
require \rackinline{apply}. Further, they should not build any
extraneous closures: unnecessarily building closures at runtime is
always a bad idea. This re-implementation requires a host that
supports variable arity functions, a widely available feature included
in such languages as JavaScript, Ruby, Java, and Python. These
languages do not generally support macros and hence are beneficiaries
of this paper's contributions.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((disj . gs) s)
    (cond
      ((null? gs) (list))
      (else (D ((car gs) s) (cdr gs) s))))

  (define (D s∞ gs s)
    (cond
      ((null? gs) s∞)
      (else
       (append∞ s∞
         (D ((car gs) s) (cdr gs) s)))))
  \end{minted}
  \caption{Eventual redefinition of \rackinline{disj}}
  \label{mnt:disj-reimplementation}
\end{listing}

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((conj . gs) s)
    (cond
      ((null? gs) (list s))
      (else (C (cdr gs) ((car gs) s)))))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (C (cdr gs)
          (append-map∞ (car gs) s∞)))))
  \end{minted}
  \caption{Eventual redefinition of \rackinline{conj}}
  \label{mnt:conj-reimplementation}
\end{listing}

\Cref{mnt:disj-reimplementation,mnt:conj-reimplementation} show our
new implementations. We re-implement these operators as shallow
wrappers over simple folds. In each, the first steps are to dispense
with the trivial case, and then to call a recursive help function that
makes no use of variadic functions. That is, all of our focus will be
on the recurring over the list \rackinline{gs}. Unlike \rackinline{D},
the function \rackinline{C} does not take in the state \rackinline{s};
the help procedure does not need the state for conjunction. In each
recursive call, we accumulate by mapping (using the special delaying
implementation of \rackinline{append-map∞} for Kanren-language
streams) the next goal in the list. This left-fold implementation of
conjunction therefore left-associates the conjuncts.

\subsection{Semantic equivalence}

A developer might derive these definitions as follows. We start with
the definition of a recursive \rackinline{disj} macro like one would
define as surface syntax over the microKanren \rackinline{disj₂}. At
the cost of an \rackinline{apply}, we can build the corresponding
explicitly recursive \rackinline{disj} function.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g₀ g₁ g ...)
     (disj₂ g₀ (disj g₁ g ...)))))

(define (disj g . gs)
  (cond
    ((null? gs) g)
    (else (disj₂ g (apply disj gs)))))
\end{minted}
  \caption{Deriving \rackinline{disj} function from macro}
  \label{mnt:disj-function-before-derivation}
\end{listing}

\noindent Since \rackinline{disj} produces and consumes goals, we can
η expand the definition in \cref{mnt:disj-function-before-derivation}
by a curried parameter \rackinline{s}. We then split \rackinline{disj}
into two mutually-recursive procedures, to build the variant in
\cref{mnt:disj-function-split}.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define ((disj g . gs) s)
  (D g gs s))

(define (D g gs s)
  (cond
    ((null? gs) (g s))
    (else ((disj₂ g (apply disj gs)) s))))
\end{minted}
  \caption{An η expanded and split definition of \rackinline{disj}}
  \label{mnt:disj-function-split}
\end{listing}

\noindent We can replace the call to \rackinline{disj₂} in
\cref{mnt:disj-function-split} by its definition in terms of
\rackinline{append∞} and perform a trivial β-reduction. The explicit
\rackinline{s} argument suggests removing the call to
\rackinline{apply} and making \rackinline{D} recursive. The result is
the version of \rackinline{D} in \cref{mnt:disj-substituted-through}.
The definition of \rackinline{disj} remains unchanged from
\cref{mnt:disj-function-split}.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define (D g gs s)
  (cond
    ((null? gs) (g s))
    (else
      (append∞ (g s)
        (D (car gs) (cdr gs) s)))))
\end{minted}
  \caption{Derivation of \rackinline{disj} function definition}
  \label{mnt:disj-substituted-through}
\end{listing}

\noindent We combine \rackinline{g} and \rackinline{s} in each clause;
this suggests constructing that stream in \rackinline{disj} and
passing it along. Adding the trivial base case to \rackinline{disj}
yields the definition in~\cref{mnt:disj-reimplementation}.


\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g g₁ gs ...)
     (conj (conj₂ g g₁) gs ...))))

(define (conj g . gs)
  (cond
    ((null? gs) g)
    (else
     (apply conj
       (cons (conj₂ g (car gs)) (cdr gs))))))
\end{minted}
  \caption{\rackinline{conj₂}-based \rackinline{conj} function and macro}
  \label{mnt:conj-function-derived-definition}
\end{listing}

We can derive the definition of \rackinline{conj} from
\cref{mnt:conj-reimplementation} via a similar process. Starting with
the variadic function based on the macro in
\cref{mnt:conj-function-derived-definition}, we first η-expand and
split the definition.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       ((apply conj
          (cons (conj₂ g (car gs)) (cdr gs)))
        s))))
\end{minted}
  \caption{Derivation of split \rackinline{conj} function definition}
  \label{mnt:conj-substituted-through}
\end{listing}
\noindent We next substitute for the definitions of \rackinline{conj} and
\rackinline{conj₂}.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (C (λ (s) (append-map∞ (car gs) (g s)))
          (cdr gs)
          s))))
\end{minted}
  \caption{Replacing \rackinline{apply} in \rackinline{C} function definition}
  \label{mnt:C-substituted-through}
\end{listing}

Finally, since \rackinline{C} only needs \rackinline{s} to
\emph{build} the stream, we can assemble the stream on the way
in---instead of passing in \rackinline{g} and \rackinline{s}
separately, we pass in their combination as a stream. The function is
tail recursive, we can change the signature in the one and only
external call and the recursive call. We show the result
in \cref{mnt:conj-reimplementation}.

Both the functional and the macro based versions of
\cref{mnt:conj-function-derived-definition} use a left fold over the
goals, whereas the versions of \rackinline{disj} use a right fold.
This is not an accident.\ Folklore suggests left associating
conjunctions tends to improve the performance of miniKanren's
interleaving search. The authors know of no thorough algorithmic proof
of such claims, but see for instance discussions and implementation
in~\cite{rosenblatt2019first} for some of the related work so far. We
have generally, however, resorted to small step visualizations of the
search tree to explain the performance impact. The authors believe it
is worth considering if we can make an equally compelling argument for
this preference through equational reasoning and comparing the
implementations of functions.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else (conj₂ g (apply conj gs)))))
\end{minted}
  \caption{A right-fold variant of \rackinline{conj}}
  \label{mnt:conj-right-fold-definition}
\end{listing}

\Cref{mnt:conj-right-fold-definition} shows a right-fold variant of
\rackinline{conj}. The choice to fold left becomes a little more
obvious after we η-expand, unfold to a recursive help function,
substitute in the definition of \rackinline{conj₂}, and β-reduce.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else (append-map∞ (apply C gs) (g s)))))
\end{minted}

\noindent Here, we cannot (easily) replace the \rackinline{apply} call
by a recursive call to \rackinline{C}, because we are still waiting
for an \rackinline{s}. We can only abstract over \rackinline{s} and
wait. Since we know that any call to \rackinline{append-map∞} we
construct will always yield a result, the version in
\cref{mnt:conj-reimplementation} is tail recursive. The equivalent
right-fold implementation needs either to construct a closure for
every recursive call, or otherwise demands a help function mutually
recursive with \rackinline{C}.

\begin{minted}[autogobble,stripall]{racket}
  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (append-map∞
         (λ (s) (C (cdr gs) ((car gs) s)))
         s∞))))
\end{minted}

If we want to implement a variadic version that does not rely on a
primitive \rackinline{conj2} and does not resort to
\rackinline{apply}, we have the two aforementioned choices. Basic
programming horse sense suggests the more elegant variant from
\cref{mnt:conj-reimplementation}.

Though this note mainly concerns the choice to implement surface
language behavior as functions, it may also point to these as more
natural user-level primitives than \rackinline{conde}. An
implementation could choose to forego \rackinline{conde} and provide
just those underlying logical primitives \rackinline{disj} and
\rackinline{conj} to the user, as in the new definition of Carmelit in
\cref{mnt:new-carmelit}. Moreover, reintroducing the nullary case only
requires a simple wrapper macro, or otherwise, a run-time
\rackinline{null?} check for a very slight cost.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (disj
    (conj (== a 'carmel-center)
          (== b 'golomb)
          (== c 'masada)
          (== d 'haneviim)
          (== e 'hadar-city-hall)
          (== f 'downtown))
    (conj (== a 'downtown)
          (== b 'hadar-city-hall)
          (== c 'haneviim)
          (== d 'masada)
          (== e 'golomb)
          (== f 'carmel-center))))
  \end{minted}
  \caption{A new Carmelit subway without \rackinline{conde}}
  \label{mnt:new-carmelit}
\end{listing}

This implementation of \rackinline{carmelit-subway} uses
our \rackinline{disj} and \rackinline{conj} functions, a far cry
better than the 11 binary logical operator nodes the programmer would
need to write in a language without macros.

\section{Tidying up the Impure Operators}\label{sec:impure}

The operators \rackinline{conda} and \rackinline{conde} look
superficially similar, syntactically. Semantically though,
\rackinline{conda}'s nested \enquote{if-then-else} behavior is quite
different, and implementing the desired behavior for
\rackinline{conda} from existing pieces exposes some strangeness. The
definition of \rackinline{conda} (see \cref{mnt:conda-implementation})
requires one or more conjuncts per clause and one or more clauses. The
consequent of each \rackinline{conda} clause is the one and only place
in the whole language implementation that permits nullary conjunctions
of goals. This soft-cut operator seems to force both nullary
conjunction and those primitive goals \rackinline{#s} and
\rackinline{#u} into the language.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g₀ g ...)) (conj g₀ g ...))
    ((conda (g₀ g ...) ln ...)
     (ifte g₀ (conj g ...) (conda ln ...)))))

(define ((ifte g₁ g₂ g₃) s)
  (let loop ((s∞ (g₁ s)))
    (cond
      ((null? s∞) (g₃ s))
      ((pair? s∞)
       (append-map∞ g₂ s∞))
      (else (lambda ()
              (loop (s∞)))))))
  \end{minted}
  \caption{A typical implementation of \rackinline{conda}}
  \label{mnt:conda-implementation}
\end{listing}

Some programmers would be perfectly satisfied just using
\rackinline{ifte} directly. But just as the standard forked
\rackinline{if} begat McCarthy's \rackinline{if} notation and
\rackinline{cond}, a programmer may eventually feel the need for a
nested implementation. Here are other (alternative) implementation
choices one could consider.

\begin{enumerate}

\item Syntactically mandate that all clauses \emph{except the final
    default clause} contain at least two goals.

\item Introduce a special clause of the \rackinline{conda} macro
  specifically for \enquote{if then} clauses with a single goal.

\item Unconditionally add a \rackinline{#s} goal to each clause
  during macro expansion.

\end{enumerate}

Each of these choices can, implicitly or explicitly, force additional
unneeded executions of unwanted goals. Working with variable arity
function syntax also suggests a more elegant solution for
\rackinline{conda}.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define ((conda q a . q-and-a*) s)
  (A (q s) a q-and-a* s))

(define (A s∞ a q-and-a* s)
  (cond
    ((null? s∞)
     (cond
       ((null? (cdr q-and-a*)) ((car q-and-a*) s))
       (else (A ((car q-and-a*) s)
                (cadr q-and-a*)
                (cddr q-and-a*)
                s))))
    ((pair? s∞) (append-map∞ a s∞))
    (else (lambda () (A (s∞) a q-and-a* s)))))
  \end{minted}
  \caption{A functional \rackinline{conda} implementation}
  \label{mnt:conda-good-re-implementation}
\end{listing}

The implementation in \cref{mnt:conda-good-re-implementation} includes
the delay-and-restart behavior of \rackinline{ifte} together with
\rackinline{conda}'s logical cascade. The \rackinline{s∞} can be
either empty, non-empty, or a function of no arguments. In the last
case, we invoke \rackinline{s∞}. Rather than building a largely
redundant implementation of \rackinline{condu}, we expose the
higher-order goal \rackinline{once} to the user. The definition of
\rackinline{once} in \cref{mnt:condu-reimplementation} is taken
directly from~\cite{friedman2018reasoned}. The programmer can simulate
\rackinline{condu} by wrapping \rackinline{once} around every test
goal.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define (once g)
  (lambda (s)
    (let loop ((s-inf (g s)))
      (cond
        ((null? s-inf) '())
        ((pair? s-inf)
         (cons (car s-inf) '()))
        (else (lambda ()
                (loop (s-inf))))))))
  \end{minted}
  \caption{The \rackinline{once} function} %% \rackinline{}
  \label{mnt:condu-reimplementation}
\end{listing}


\section{Remainders and Practicalities}\label{sec:functional}

We have not fully obviated the use of macros. In this section we
collect together some workarounds to obviate macros in the rest of the
implementation. Some of these come with significant drawbacks. With
these, however, a programmer in even a pedestrian functional language
should be able to directly translate the implementation and our test
programs.

\paragraph{\rackinline{define}}

The microKanren programmer can just
use their host language's \rackinline{define} feature to construct
relations as host-language functions, and manually introduce the
delays in relations. This may be a larger concession than it looks,
since it exposes the delay and interleave mechanism to the user, and
both correct interleaving and even the termination of relation
\emph{definitions} rely on a whole-program correctness property of
relation definitions having a delay. \Cref{mnt:subtleo} relies on a
help function \rackinline{Zzz} to introduce delays, akin to some
earlier implementations~\cite{hemann2013muKanren}.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define (subtleo x)
  (Zzz
    (disj
      (subtleo x)
      (== x 'cat))))
  \end{minted}
  \caption{Omitting the delay is a subtle bug}
  \label{mnt:subtleo}
\end{listing}

\paragraph{\rackinline{fresh}}

In any implementation there must be
some mechanism to produce the next fresh variable. For example, we
treat the natural numbers as an indexed set of variables, and we
thread the current index through the computation. We use
\rackinline{add1} to get the next index; to go from index to variable
is the identity function. For another example, we could represent each
variable using a unique memory location,
sokuza-kanren~\cite{kiselyov2006taste} style, and the operation to
produce a new variable requires introducing an unused memory location.
Depending on the implementation of variables, you may also need
additional functions to support your implementation of variables. If
variables are not from an indexed set, you may also need an operation
to (re)construct specifically the first element of the set, or
otherwise store that value for later re-use.

Of course, one of these approaches requires memory allocation and
external global state, while the other does not. Furthermore, the
latter approach models logic variables as coming from a single global
pool rather than reusing them separately across each disjunct, and so
requires some global store and strictly more logic variables overall.

With this latter approach, however, we can expose \rackinline{var}
directly to the programmer and the programmer can use \rackinline{let}
bindings to introduce several logic variables simultaneously.

\paragraph{\rackinline{run}}

We note that we can also implement \rackinline{run} without using
macros. Using the purely-functional implementation of logic variables,
the definitions of \rackinline{run} and \rackinline{run*} easily
translate to functions
like \rackinline{call/initial-state}~\cite{hemann2013muKanren}. The
query is itself expressed as a goal that introduces the first logic
variable \rackinline{q}. The pointer-based logic variable approach
forces the programmer to explicitly invoke \rackinline{reify} as
though it were a goal as the last step of executing the query, as in
\cref{mnt:run-query}.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(call/initial-state 1
  (let ((q (var 'q)))
    (conj
      (let ((x (var 'x)))
        (== q x))
      (reify q))))
  \end{minted}
  \caption{Queries as expressed with global-state variables}
  \label{mnt:run-query}
\end{listing}

\section{Future Work}\label{sec:conclusion}

This note shows how to provide a somewhat more concise core language
that significantly reduces the need for macros. The result almost
rivals the expressivity of the full \enquote{microKanren + macros}
approach. Variadic functions make this implementation much more
convenient for the end programmer, and Scheme's polyvariadic function
syntax ensures at a host-language level that the microKanren
programmer provides at least one parameter to \rackinline{conj}
and \rackinline{disj}.

The old desugaring macros do not seem to suggest how to associate the
calls to the binary primitives---both left and right look equally
nice. Forcing ourselves to program the solution functionally, and the
restrictions we placed on ourselves in this reimplementation, removed
a degree of implementation freedom and led us to what seems like the
right solution.

The result is closer to the design of Prolog, where the user
represents conjunction of goals in the body of a clause with a comma
and disjunction, either implicitly in listing various clauses or
explicitly with a semicolon. We assume it is agreed that our
definitions of \rackinline{disj} and \rackinline{conj} themselves are
sufficiently high-level operators for a surface language and that the
zero-element base cases are at best unnecessary and likely
undesirable; given the opportunity to define a surface language and
its desugaring, we really shouldn't tempt the programmer by making
undesirable programs representable when we can avoid it.

Techniques for
implementing \rackinline{defrel}, \rackinline{fresh} and
\rackinline{run} (and \rackinline{run*}) without macros come with
serious drawbacks. These include exposing the implementation of
streams and delays, and the inefficiency and clumsiness of introducing
variables one at a time, or the need to reason with global state.

From time to time we find that the usual miniKanren implementation is
\emph{itself} lower-level than we would like to program with
relations. Early microKanren implementations restrict themselves to
\rackinline{syntax-rules} macros. Some programmers use macros to
extend the language further as with
\rackinline{matche}~\cite{keep2009pattern}. Some constructions over
miniKanren, such as
\rackinline{minikanren-ee}~\cite{ballantyne2020macros}, may rely on
more expressive macro systems like
\rackinline{syntax-parse}~\cite{culpepper2012fortifying}.

We would still like to know if our desiderata here are \emph{causally}
related to good miniKanren performance. Can we reason at the
implementation level and peer through to the implications for
performance? If left associating \rackinline{conj} is indeed uniformly
a dramatic improvement, the community might consider reclassifying
left-associative conjunction as a matter of correctness rather than an
optimization, as in \enquote{tail call optimization} vs.
\enquote{Properly Implemented Tail Call
  Handling}~\cite{felleisen2014requestions}. Regardless, we hope this
document helps narrow the gap between implementations in functional
host languages with and without macro systems and helps implementers
build more elegant, expressive and efficient Kanrens in their chosen
host languages.

\begin{acks}

  Thanks to Ken Shan and Jeremy Siek, for helpful discussions and
  debates during design decision deliberations. Thanks also to Greg
  Rosenblatt and Michael Ballantyne for their insights and
  suggestions. We would also like to thank our anonymous reviewers
  for their insightful contributions.

\end{acks}

\printbibliography{}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
