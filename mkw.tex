\documentclass[sigplan,screen,draft,anonymous,review,natbib=false]{acmart}

\usepackage{polyglossia} %% for xelatex use polyglossia, needed for csquotes
\setdefaultlanguage[variant=american]{english}


\PassOptionsToPackage{cache=false,newfloat=true}{minted}
\PassOptionsToPackage{unicode}{hyperref}

\usepackage[capitalize,nameinlink]{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\RequirePackage[
  datamodel=acmdatamodel,
  style=acmnumeric,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{mkw.bib}


\usepackage{minted}
\usepackage[strict,autostyle]{csquotes} %% enquote &c that doesn't interfere w/cdlatex usage
%% http://ftp.lyx.org/pub/tex-archive/macros/latex/contrib/csquotes/csquotes.pdf

\setmonofont{DejaVuSansMono}[Scale=MatchLowercase] %% What is this scale option?
\tracinglostchars=2

\newmintinline[rackinline]{racket}{}
\newmintinline{prolog}{}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}



%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Improving microKanren implementations using variadic functions}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Jason Hemann}
\email{jhemann@northeastern.edu}
\orcid{1234-5678-9012}
\author{Daniel P Friedman}
\email{dfried@cs.indiana.edu}
\orcid{1234-5678-9012}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Hemann et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We describe here how, at the cost of an additional language
feature---namely variadic and \enquote{rest argument} functions---we
can implement a slightly higher-level kernel language. This insight
leads to a shorter overall implementation that is also more performant
and, perhaps, a bit more elegant.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

microKanren~\cite{hemann2013muKanren} is a compact approach to
implementing a relational programming language. One of the authors'
design goals for this reimplementation of miniKanren was to partition
off macros that implemented the surface syntax, leaving an underlying
pure functional core. In doing so, the authors hoped this separation
would simultaneously aid future would-be implementers when studying
the source code, and also that the functional core would make the
language easier to port to other functional host languages. This
microKanren approach has found purchase as a tool for understanding
through implementation the guts of a relational programming language.
To support both those efforts, the authors chose to program
microKanren in a deliberately small and quotidian set of Scheme
primitives.

Until now microKanren implementation technique had divided the
programming languages of the world more or less into the expressive
macro system \enquote{have}s and the macro system-less \enquote{have
  not}s. This note shows how an implementer using a functional
language with variadic (any number of arguments) functions but without
a macro system can achieve an intermediate point. We also allow
ourselves the luxury of some changes to the core language's syntax.

Even implementers using and programmers studying implementations
written in languages \emph{with} sufficiently expressive macro systems
can benefit from these improvements. There are benefits to parsimony.
For a language this means having a small highly expressive set of
primitives~\cite{somedescriptionofscheme}. The microKanren authors
measured their result by the number of lines in the core
implementation, the number of additional lines for their and the
limited features they required from the host. So replacing less
powerful language primitives by comparatively short but more powerful
variants is a win. Beyond that, this more powerful kernel language
obviates several macros in the desugaring layer.

Beyond being a conceptually simpler foundation for a full Kanren
language, this implementation is more \emph{efficient}. The source of
the original inefficiency---the right-association of conjunctions---
is already known miniKanren implementation folklore. We were
pleasantly surprised that code improvement \enquote{horse sense} and
thinking about the expressivity of primitives also gave us improved
performance. This same horse sense might lead one to suggest these
improved variants should have been the

In \cref{sec:all-aboard}, we briefly revisit microKanren implementations
status quo ante and illustrate why surface syntax macros seemed
practically mandatory. In~\cref{sec:conde}, we discuss the
re-implementation of conjunction and disjunction, and in
\cref{sec:impure} we discuss the re-implementation of the impure
operators. We close with a discussion of some performance impacts of
these implementation choices, and consider how Kanren language
implementers outside of the Scheme family might benefit from this
re-implementation

\section{All Aboard}\label{sec:all-aboard}

We assume the reader is familiar with the miniKanren language and in
particular with microKanren implementations. We refer the reader
to~\cite{friedman2018reasoned,hemann2013muKanren,hemann2016small} for
further explanation, or to~\href{minikanren.org}{minikanren.org} for a
slew of implementations across many host languages.

The shortest subway system in the world is Haifa's Carmelit, with only
six stations. The system is acylic, so its trains travel back and
forth. If we wanted to describe the order in which we rode the train
from the beginning to the end, we could use the
\rackinline|carmelit-subway| relation in ~\cref{mnt:carmelit}. We
express this relation using the more compact miniKanren syntax because
unfolding this relation into binary conjunctions and disjunctions
would be painful. We certainly \emph{could} write it out by hand---in
fact, we could write it out many ways. We could nest those
conjunctions to the left, or to the right, or try and reduce the
indentation by trying to keep them somewhat balanced.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(defrel (carmelit-subway a b c d e f)
  (conde
   ((== a 'carmel-center)
    (== b 'golomb)
    (== c 'masada)
    (== d 'haneviim)
    (== e 'hadar-city-hall)
    (== f 'downtown))
   ((== a 'downtown)
    (== b 'hadar-city-hall)
    (== c 'haneviim)
    (== d 'masada)
    (== e 'golomb)
    (== f 'carmel-center))))
  \end{minted}
  \caption{A miniKanren implementation of the Carmelit subway.}
  \label{mnt:carmelit}
\end{listing}

We defer that discussion to~\cref{sec:conde}; for now, take the point
that those in languages without macros who intended to use this
language for even fairly trivial tasks could become overwhelmed by the
low-level details of programming in a microKanren such as binary
conjunction and disjunction, with all the difficulties of a shallow
embedding. E.g., a small programming mistake, such as incorrectly
nesting a conjunct somewhere in a long conjunction chain, can cause
relatively obscure errors and reading those error messages forces the
programmer out of the microKanren-DSL thinking, and back into the host
programming language's debug model.

\section{\rackinline|conde| and logical goal constructors}\label{sec:conde}

Programmers deserve better than having to chain their logic together
like building circuitry from logic gates. Such higher-level operations
may or may not be present in the core language, but if not the
programmer will reasonably expect some syntax sugar to provide them.
Witness the Scheme's \rackinline|and| and \rackinline|or| macros as
examples.
\Cref{mnt:conde-implementation,mnt:conj-and-disj-implementation}
contain a typical implementation of miniKanren's \rackinline|conde|
operator, this one taken from \citetitle{friedman2018reasoned}. As
advertised, the \rackinline|conde| macro is a shallow syntactic
wrapper for an $n$-way disjunction (\rackinline|disj|) of $n$-way
conjunctions (\rackinline|conj|).

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define-syntax conde
  (syntax-rules ()
    ((conde (g ...) ...)
     (disj (conj g ...) ...))))
  \end{minted}
\caption{A typical implementation of \rackinline|conde|.}
  \label{mnt:conde-implementation}
\end{listing}


\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define-syntax conj
  (syntax-rules ()
    ((conj) S)
    ((conj g) g)
    ((conj g0 g ...) (conj₂ g0 (conj g ...)))))

(define ((conj₂ g₁ g₂) s)
  (append-map g₂ (g₁ s)))

(define-syntax disj
  (syntax-rules ()
    ((disj) F)
    ((disj g) g)
    ((disj g0 g ...) (disj₂ g0 (disj g ...)))))

(define ((disj₂ g₁ g₂) s)
  (append (g₁ s) (g₂ s)))
  \end{minted}
  \caption{Macro based implementations of \rackinline|conj| and \rackinline|disj|.}
  \label{mnt:conj-and-disj-implementation}
\end{listing}

\Cref{mnt:conj-and-disj-implementation} contains implementations of
the underlying conjunction and disjunction operations. Here
\rackinline|S| (\rackinline|F|) represents a primitive goal that
unconditionally succeeds (fails). We omit the underlying
implementations of \rackinline|append| and \rackinline|append-map|, as
these are standard and remain constant over the course of this
discussion.

As implemented, \rackinline|conj| and \rackinline|disj| are not
\emph{quite} defined as simple recursions over their binary functional
primitives. The definition of 0-way conjunction (disjunction) is
independent of the unfolding of \rackinline|conj₂|
(\rackinline|disj₂|). In a sense the \rackinline|conj| and
\rackinline|disj| macros amalgamate primitive success and failure
goals with those recursive unfoldings of more-than-binary logical
connectives that terminate in a one-element base case.

These zero-way logical operation base cases don't add much. The
programmer who wants to write an elegant, efficient solution to a pure
relational programming task would not encounter these additional base
cases in his \rackinline|conde| expressions. The programmer knows
statically how these goals will behave, so there is no benefit to
executing them. A conjunction of no goals would simply succeed, and a
disjunction of no goals would simply fail. Truthfully, only the impure
\rackinline|conda| operator seemed to require these additional base
cases (we discuss this further in~\cref{sec:impure}).

If we mandate that disjunction be a function of one-or-more arguments
(or, in another parlance, \enquote{polyvariadic}), we can implement
our disjunction as a shallow wrapper over a left-fold. For clarity,
and to avoid \enquote{namespace collisions}, we use \rackinline|D| for
our re-implementation of disjunction and we call its internal help
function \rackinline|D-rec|.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define ((D g₁ . gs) s)
  (D-rec (g₁ s) gs s))

(define (D-rec s∞ gs s)
  (cond
    ((null? gs) s∞)
    (else
      (D-rec (append s∞ ((car gs) s)) (cdr gs) s))))
  \end{minted}
  \caption{A functional re-implementation of disjunction.}
  \label{mnt:disj-re-implementation}
\end{listing}

From the first goal (the host language syntactically guarantees one
must exist) and a state, \rackinline|D| can produce an answer stream
\rackinline|(g₁ s)|, which it passes along as the first argument to
\rackinline|D-rec|. The function \rackinline|D-rec| is merely a fold
over the list of the remaining goals. Whereas the implementation in
\cref{mnt:conj-and-disj-implementation} implements general disjunction
as a right fold, the function \rackinline|D-rec| is instead a
tail-recursive left fold, accumulating the resulting answer stream in
\rackinline|s∞|.

miniKanren's biased search heuristic causes some operational
differences between this reimplementation and the older one. With this
implementation, instead of the \emph{first} goal being the most
heavily weighted in the search, here the \emph{last} goal is most
heavily weighted. Because $n$-ary disjunction is now built in to the
functional definition, this behavior is now transparently visible in
the implementation of \rackinline|D-rec|. Imagine for a moment that in
the given state \rackinline|s| each goal in~\rackinline|(g₁ . gs)|
produces infinitely many answers. The \rackinline|append| is doing a
fair interleaving between its two stream arguments: giving one a
little time to work and then handing off to the other. At each
recursion, approximately half the answers in that stream come from the
most recently evaluated goal, and so the resources dedicated to all
the preceding goals is halved, in order to accommodate this new one.

A declarative programmer oughtn't need to concern himself with the
operational search behavior, and since miniKanren provides a complete
search, a query should still return the same bag of answers, so we do
not see this as a problem; we just consider it an interesting
distinction. If however operationally-aware programmers found the
\enquote{reversed weighting} unintuitive, some language front end
could rearrange the programmer's arguments. For example, reversing a
list of arguments is an exemplary use of an APS macro.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define ((C g₁ . gs) s)
  (C-rec (g₁ s) gs))

(define (C-rec s∞ gs)
  (cond
    ((null? gs) s∞)
    (else
      (C-rec (append-map (car gs) s∞) (cdr gs)))))
  \end{minted}
  \caption{A functional re-implementation of conjunction.}
  \label{mnt:conj-re-implementation}
\end{listing}

Our re-implementation of conjunction
in~\cref{mnt:conj-re-implementation} tells a similar story. The
function \rackinline|C-rec| does not take in the state \rackinline|s|;
the help procedure does not need the state for conjunction. In each
recursive call, the state is accumulated by mapping (using the special
delaying implementation of append-map for miniKanren streams) the next
goal in the list. This tail-recursive left-fold implementation happens
to also left-associate the conjuncts. Left associating conjuncts is so
important dramatically improves miniKanren's search. A full through
explanation of the behavior is outside the scope of our work here, but
see discussions by Rosenblatt and Ballantyne~\cite{here,nowhere}. The
matter is so significant that the community might consider
reclassifying it as a matter of correctness.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(defrel (carmelit-subway a b c d e f)
  (D
   (C (== a 'carmel-center)
      (== b 'golomb)
      (== c 'masada)
      (== d 'haneviim)
      (== e 'hadar-city-hall)
      (== f 'downtown))
   (C (== a 'downtown)
      (== b 'hadar-city-hall)
      (== c 'haneviim)
      (== d 'masada)
      (== e 'golomb)
      (== f 'carmel-center))))
  \end{minted}
  \caption{A reimplemented Carmelit subway without \rackinline|conde|.}
  \label{mnt:new-carmelit}
\end{listing}



\section{Cleaning up the Impure Operators}\label{sec:impure}

The zero-ary conjunction and disjunction base cases both forced
primitive goals \rackinline|S| and \rackinline|F| into the language
and also hid the opportunity of functional left-fold implementations
as helpers to variadic surface functions. The zero-ary conjunction
case was itself implemented as an answer to an earlier problem in
implementing an \rackinline|if-then-else| soft-cut operator. The
zero-ary disjunction base case was not \emph{really} required, but
given that we needed one the other came along for the ride, so to
speak.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g0 g ...)) (conj g0 g ...))
    ((conda (g0 g ...) ln ...)
     (ifte g0 (conj g ...) (conda ln ...)))))

(define ((ifte g1 g2 g3) s)
  (let loop ((s-inf (g1 s)))
    (cond
      ((null? s-inf) (g3 s))
      ((pair? s-inf)
       (append-map g2 s-inf))
      (else (lambda ()
              (loop (s-inf)))))))
  \end{minted}
  \caption{A typical implementation of \rackinline|conda|.}
  \label{mnt:conda-implementation}
\end{listing}

The operators \rackinline|conda| and \rackinline|conde| look
superficially similar, syntactically. Semantically though, the
disjunction and nested \enquote{if-then-else} behaviors are quite
different, and implementing the desired behavior for this
\rackinline|conda| from existing combinators raises some oddities. The
definition of \rackinline|conda| already rules out zero-way
conjunctions of goals in the clause body as well as zero-way
disjunctions of such clauses. Another oddity is that, for a
\rackinline|conda| syntax that permits one-or-more-goals in each
clause, the final clause of the \rackinline|conda| definition is the
one and only place in the implementation that may require a nullary
conjunction of goals.

There are work-arounds. One could: 1. special case one-goal clauses in
the last clause of the \rackinline|conda| implementation with a
special \rackinline|ifte| variant. 2. special case that clause by
introducing \rackinline|S| as an additional goal 2. mandate that all
clauses in \rackinline|conda| contain at least two goals. 3. mandate
that all clauses \emph{except the final default clause} contain at
least two goals. 4. build a special-case conjunction solely for this
purpose. In all but the first of these choices, either the
implementation implicitly or the syntax explicitly can force
additional unneeded executions of unwanted goals. The first choices
seems even worse for introducing another complex function definition
that is nearly identical to one used in the below case.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g0 g ...)) (conj g0 g ...))
    ((conda (g0) ln ...)
     (ife g0 (conda ln ...)))
    ((conda (g0 g ...) ln ...)
     (ifte g0 (conj g ...) (conda ln ...)))))

(define ((ife g1 g3) s)
  (let loop ((s-inf (g1 s)))
    (cond
      ((null? s-inf) (g3 s))
      ((pair? s-inf) s-inf)
      (else (lambda ()
              (loop (s-inf)))))))

(define ((ifte g1 g2 g3) s)
  ...)
  \end{minted}
  \caption{An inauspicious re-implementation of \rackinline|conda|.}
  \label{mnt:conda-bad-re-implementation}
\end{listing}

Here too, removing macros and relying on variable arity function
definition provides a more elegant solution. Some programmers would be
perfectly satisfied to have lived forever with \rackinline|ifte|
itself. But just as the standard forked \rackinline|if| begat
McCarthy's \rackinline|if| notation and \rackinline|cond|, we can
suspect that a programmer would eventually feel the need for a nested
implementation.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define ((conda q a . q-and-a*) s)
  (A-rec (q s) a q-and-a* s))

(define (A-rec s-inf a q-and-a* s)
  (cond
    ((null? s-inf)
     (cond
       ((null? (cdr q-and-a*)) ((car q-and-a*) s))
       (else (A-rec ((car q-and-a*) s)
                    (cadr q-and-a*)
                    (cddr q-and-a*) s))))
    ((pair? s-inf) (append-map-inf a s-inf))
    (else (lambda () (A-rec (s-inf) a q-and-a* s)))))
  \end{minted}
  \caption{A functional \rackinline|conda| implementation.}
  \label{mnt:conda-bad-re-implementation}
\end{listing}

The implementation in~\cref{mnt:conda-bad-re-implementation} includes
the delay-and-restart behavior of \rackinline|ifte| together with
\rackinline|conda|'s logical cascade.

\subsection{\rackinline|condu|}

We have not yet addressed~\rackinline|condu|. We could implement this
for functional programmers with a variant
of~\cref{mnt:conda-bad-re-implementation}. However, we instead choose
to make \rackinline|once| a primitive higher-order goal.

\begin{listing}
  \begin{minted}[autogobble,stripall,linenos]{racket}
(define (once g)
  (lambda (s)
    (let loop ((s-inf (g s)))
      (cond
        ((null? s-inf) '())
        ((pair? s-inf)
         (cons (car s-inf) '()))
        (else (lambda ()
                (loop (s-inf))))))))
  \end{minted}
  \caption{A functional \rackinline|conda| implementation.}
  \label{mnt:conda-bad-re-implementation}
\end{listing}

\section{Conclusion}\label{sec:conclusion}

narrows the gap between implementations in functional host languages
with and without macro systems.

More languages that ever before support variable arity
functions/methods (aka \verb|varargs| aka \verb|slurpy| methods),
including Raku, Java, and Ruby, to name just a few. Many of these
languages also support polyvariadic functions. The authors hope that
this document helps implementers build more elegant, expressive and
efficient Kanrens in their chosen host languages.

Languages with variadic but without polyvariadic (wits \enquote{at
  least $k$ arguments}) functions---how do they fare here.

We take it as granted that conjunction and disjunction themselves are
sufficiently high-level operators for a surface language and that the
0-element base cases are at best unnecessary and likely undesireable.

Given the opportunity to define a surface language and its desugaring,
we really shouldn't tempt the programmer by making undesireable
programs representable when we can avoid doing so.

Of course, no implementer \emph{needs} a macro system to implement a
shallow embedding of an LP language. In our implementations, we still
use macros to implement \rackinline|define-relation| and
\rackinline|fresh|, the former to prevent exposing the implementation
of streams and delays, and the latter both for the added efficiency
and to avoid the awkwardness of introducing each variable one at a
time.

From time to time we find that the usual miniKanren implementation is
itself lower-level than we would like to program with relations.
Expert miniKanren programmers use macros to extend the language yet
again, as with \rackinline|matche|, and also with wholly more
expressive and highly optimized language forms, as in the original
\rackinline|Kanren|. It is nice to find we can spread some of that
extra expressiveness to the broader Kanren language community.

This note shows that, at the cost of one additional feature--namely
variadic functions---implementers provide a somewhat more powerful
core language and significantly reduce the need for macros in
implementing a language as expressive as the full
\verb|microKanren + Macros| approach provides.

\begin{acks}

Thanks also to Ken Shan and Jeremy Siek, for helpful discussions and
debates during design decision deliberations.

\end{acks}

\printbibliography{}

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.


\documentclass[sigplan,screen]{acmart}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
