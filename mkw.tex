\documentclass[sigplan,screen,draft,anonymous,review,natbib=false]{acmart}
%% ∞
%% …
%% ₀
%% ₁
%% ₂
%% ₃
\usepackage{fontspec,newunicodechar}
\usepackage{hyphenat} %% electromagnetic\hyp{}endioscopy
\usepackage[shortcuts]{extdash}
\usepackage{microtype} %% provides tighter text formatting
\usepackage{polyglossia} %% for xelatex use polyglossia, needed for csquotes
\setdefaultlanguage[variant=american]{english}

\PassOptionsToPackage{cache=false,newfloat=true}{minted}
\PassOptionsToPackage{unicode}{hyperref}

\usepackage[capitalize,nameinlink]{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\RequirePackage[
  datamodel=acmdatamodel,
  style=acmnumeric,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{mkw.bib}

\usepackage{nag} %% should complain about old and outdated commands
\usepackage{minted}
\usepackage[strict,autostyle]{csquotes} %% enquote &c that doesn't interfere w/cdlatex usage
%% http://ftp.lyx.org/pub/tex-archive/macros/latex/contrib/csquotes/csquotes.pdf
%% \usepackage[xspace]{ellipsis} they suggest using xetex instead
%% \usepackage{setspace} %% set the spacing (single double, etc)

\setmonofont{DejaVuSansMono}[Scale=MatchLowercase]
\tracinglostchars=2
\usepackage[defaultlines=3,all]{nowidow} %% Eliminates widow and orphans
\usepackage{todonotes}

\newmintinline[rackinline]{racket}{}
\newmintinline{prolog}{}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[mKW '22]{miniKanren Workshop}{September 15,
  2022}{Ljubljana, Slovenia}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title[Towards criteria for implementations]{Towards criteria for
  implementations of variable arity conjunction and disjunction in
  microKanren}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Jason Hemann}
\email{jhemann@northeastern.edu}
\orcid{1234-5678-9012}
\author{Daniel P. Friedman}
\email{dfried@cs.indiana.edu}
\orcid{1234-5678-9012}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Hemann et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  We describe here how, at the cost of an additional language
  feature---namely variadic and \enquote{rest argument} functions---we
  can implement a slightly higher-level kernel language. This
  implementation includes conjunction and disjunction for microKanren
  that do not create superfluous closures. The result is a
  shorter and simpler overall implementation that is more elegant.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

microKanren~\cite{hemann2013muKanren} is a compact approach to
implementing a relational programming language. The microKanren
approach has worked out well as a tool for understanding the guts of a
relational programming language through studying its implementation. A
design goal for this reimplementation of miniKanren has been to drop
some of the complexity associated with mixing macros and function
definitions, especially for those implementers trying to avoid macros.
This goal has not been met, but we show how the macros for conjunction
and disjunction can be avoided, leaving an underlying pure functional
core. In doing so, the authors hope this separation will
simultaneously aid future would-be implementers when studying the
source code, and also that the functional core would make the language
easier to port to other functional host languages. To support both
those efforts, the authors have chosen to program these foundational
parts of (relational) logic programming using a new kind of
microKanren in a deliberately small and workaday set of Scheme
primitives.

Until now microKanren implementations have divided the programming
languages of the world more or less into the expressive macro system
\enquote{haves} and the macro system-less \enquote{have nots}. This
note shows how an implementer using a functional language with
variadic (any number of arguments) functions but without
\rackinline|apply| or a macro system can still achieve an intermediate
point.

Even implementers using and programmers studying implementations
written in languages \emph{with} sufficiently expressive macro systems
can benefit from these improvements. There are benefits to using a
limited set of features in a language. Based on an evaluation
of~\href{minikanren.org}{minikanren.org}, earlier microKanren
implementers measured their results by the number of lines in the core
implementation, the number of additional lines for the surface syntax,
and the limited features they required from the host. So replacing
less powerful language primitives by comparatively short but more
powerful variants is a win. Beyond that, this more powerful kernel
language obviates several macros in the desugaring layer, and
eventually leads us to see merit in modifying the core language's
syntax. This is, of course, subjective.

Beyond being a conceptually simpler foundation for a full Kanren
language at the level of \citetitle{friedman2018reasoned}, this
implementation appears to be more \emph{efficient}. The source of the
original inefficiency---right-associative conjunction---is already
known miniKanren implementation folklore. We were pleasantly surprised
that thinking about the expressivity of primitives and code
improvement \enquote{horse sense} led us to this same idea. That very
horse sense might lead one to suggest these improved variants should
actually be the external programming constructs. This, too, is very
speculative.

In \cref{sec:all-aboard}, we briefly revisit microKanren
implementations and illustrate why surface syntax
macros had seemed practically mandatory. In~\cref{sec:conde}, we implement conjunction and disjunction, and in
\cref{sec:impure} we discuss the re-implementation of the impure
operators. We close with a discussion of some performance impacts of
these implementation choices, and consider how Kanren language
implementers outside of the Scheme family might benefit from these
alternative implementations.

\section{All Aboard!}\label{sec:all-aboard}

We assume the reader is familiar with the miniKanren language as
described in \citetitle{friedman2018reasoned} and in particular with
microKanren implementations. See \href{minikanren.org}{minikanren.org}
for more implementations across multiple host languages.

The world's shortest subway system is Haifa's Carmelit, with only
six stations. The system is a line, so its trains travel back and
forth. If we wanted to describe the order in which we rode the train
from the beginning to the end, we could use the
\rackinline|carmelit-subway| relation in~\cref{mnt:carmelit}. We
express this relation using the more compact miniKanren syntax because
unfolding this relation into binary conjunctions and disjunctions
would be painful. We certainly \emph{could} write it out by hand---in
fact, we could write it out many ways. We could nest those
conjunctions to the left, or to the right, or try and reduce the
indentation by trying to keep them somewhat balanced: the program
itself does not seem to obviously encourage one particular choice.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (conde
    ((== a 'carmel-center)
     (== b 'golomb)
     (== c 'masada)
     (== d 'haneviim)
     (== e 'hadar-city-hall)
     (== f 'downtown))
    ((== a 'downtown)
     (== b 'hadar-city-hall)
     (== c 'haneviim)
     (== d 'masada)
     (== e 'golomb)
     (== f 'carmel-center))))
  \end{minted}
  \caption{A miniKanren implementation of the Carmelit subway.}
  \label{mnt:carmelit}
\end{listing}

We defer further discussion on this point to~\cref{sec:conde}. Here we
intend just to illustrate that those programming in a microKanren in a
macro-less host language, for even fairly trivial tasks, could get
bothered by low-level details such as binary conjunction and
disjunction, with all the difficulties of a shallow embedding. E.g., a
small programming mistake, such as incorrectly nesting a conjunct
somewhere in a long conjunction chain, can cause relatively obscure
errors and reading those error messages forces the programmer out of
the microKanren-DSL thinking, and back into the host programming
language's debug model.

\section{\rackinline|conj| and \rackinline|disj| logical goal
  constructors}\label{sec:conde}

Programmers rightly expect better than having to chain their logic
together like building circuitry from logic gates. Such higher-level
logical operations may or may not be present in the core language, but
if not, the programmer will reasonably expect some syntax sugar to
provide them. Witness Scheme's \rackinline|and| and
\rackinline|or| macros as examples.~\cite{shinn2013revisedreport} Like
in a typical miniKanren implementation, the \rackinline|conde| macro
is a shallow syntactic wrapper for disjuctive normal form.
~\Cref{mnt:conj-and-disj-reimplementation} shows our new
implementation.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (C (cdr gs)
          (append-map∞ (car gs) s∞)))))

  (define ((disj g . gs) s)
    (D g gs s))

  (define (D g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (append∞ (g s)
         (D (car gs) (cdr gs) s)))))

(define-syntax conde
  (syntax-rules ()
    ((conde (g g₁ ...) ...)
     (disj (conj g g₁ ...) ...))))
  \end{minted}
  \caption{Re-implementations of \rackinline|conj| and \rackinline|disj|.}
  \label{mnt:conj-and-disj-reimplementation}
\end{listing}

Mandating one-or-more arguments lets us re-implement these operators
as shallow wrappers over folds. The first step in each is merely to
remove the rest argument \rackinline|gs| and act as if there were no
need for a rest argument. That is, all of our focus will be on the
\emph{list}, \rackinline|gs|. These implementations rely on variadic
functions, but do not require \rackinline|apply|. They no longer rely
on binary \rackinline|conj₂| and \rackinline|disj₂|, and they do not
build any extraneous closures. Unnecessarily building closures at
runtime is always a bad idea.

The function \rackinline|C| does not take in the state \rackinline|s|;
the help procedure does not need the state for conjunction. In each
recursive call, we accumulate by mapping (using the special delaying
implementation of append-map for miniKanren streams) the next goal in
the list. This left-fold implementation of conjunction therefore
left-associates the conjuncts.

Compare these to typical macro-based microKanren implementations of
the underlying conjunction and disjunction operations in
\cref{mnt:conj-and-disj-implementation}. Here, \rackinline|#s| and
\rackinline|#f| represent primitive goals that unconditionally succeed
and fail, respectively. Those \rackinline|conj| and \rackinline|disj|
macros are not \emph{quite} defined as simple recursions over their
binary functional primitives. The definition of 0-way conjunction
(disjunction) is independent of the unfolding of \rackinline|conj₂|
(\rackinline|disj₂|). In a sense the \rackinline|conj| and
\rackinline|disj| macros confuse and entangle primitive success and
failure goals with those recursive unfoldings in terms of the binary
operators.

Those zero-way logical operation base cases don't add much. The
programmer who tries to write an elegant, efficient solution to a pure
relational programming task would not encounter these additional base
cases in his \rackinline|conde| expressions. The programmer knows
statically how these goals should behave, so there is no benefit to
executing them. A conjunction of no goals would simply succeed, and a
disjunction of no goals would simply fail. Truthfully, only the impure
\rackinline|conda| operator seems to require these additional base
cases (discussed further in~\cref{sec:impure}).

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conj
  (syntax-rules ()
    ((conj) #s)
    ((conj g) g)
    ((conj g₀ g ...) (conj₂ g₀ (conj g ...)))))

(define ((conj₂ g₁ g₂) s)
  (append-map g₂ (g₁ s)))

(define-syntax disj
  (syntax-rules ()
    ((disj) #f)
    ((disj g) g)
    ((disj g₀ g ...) (disj₂ g₀ (disj g ...)))))

(define ((disj₂ g₁ g₂) s)
  (append (g₁ s) (g₂ s)))
  \end{minted}
  \caption{Macro based implementations of \rackinline|conj| and \rackinline|disj|.}
  \label{mnt:conj-and-disj-implementation}
\end{listing}

\subsection{Implementation correctness}

A developer equipped with variadic functions might discover these
definitions as follows. We start with the definition of
\rackinline|disj| from \cref{mnt:conj-and-disj-reimplementation}. At
the cost of an \rackinline|apply|, we can define this as a single
explicitly recursive function.

\begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (cond
      ((null? gs) (g s))
      (else
       (append∞ (g s)
         ((apply disj gs) s)))))
\end{minted}

\noindent We inverse β-substitute in the recursive case, to draw out a
similarity between the two clauses.

\begin{listing}
\begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (cond
      ((null? gs) (g s))
      (else ((λ (s)
               (append∞ (g s)
                 ((apply disj gs) s)))
             s))))
\end{minted}
\end{listing}

\noindent We can replace the call to \rackinline|append∞| by the definition
of \rackinline|disj₂|.

\begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (cond
      ((null? gs) (g s))
      (else ((disj₂ g (apply disj gs)) s))))
\end{minted}

\noindent Now \rackinline|s| is a curried parameter we can η away. We
provide the completed functional definition and a comparable to the
macro-based implementation
in~\cref{mnt:disj-function-and-macro-derived-definition}.

\begin{listing}
\begin{minted}[autogobble,stripall]{racket}
  (define (disj g . gs)
    (cond
      ((null? gs) g)
      (else (disj₂ g (apply disj gs)))))

  (define-syntax disj
    (syntax-rules ()
      ((disj g) g)
      ((disj g gs ...) (disj₂ g (disj gs ...)))))
\end{minted}
  \caption{Derived \rackinline|disj₂|-based function and macro.}
  \label{mnt:disj-function-and-macro-derived-definition}
\end{listing}

We can demonstrate the correctness of our \rackinline|conj| from
\cref{mnt:conj-and-disj-reimplementation} in the same manner. We first
deconstruct the stream accumulator back into its two constituent
pieces.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (C (λ (s) (append-map∞ (car gs) (g s)))
          (cdr gs)
          s))))
\end{minted}

\noindent This we can collapse into a single recursive function,
bringing the goal to the front.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (cond
      ((null? gs) (g s))
      (else
       ((apply conj
          (cons
            (λ (s) (append-map∞ (car gs) (g s)))
            (cdr gs))
        s)))))
\end{minted}

\noindent We can replace the abstraction over
\rackinline|append-map∞|, which is to say the body of
\rackinline|conj₂|, by its definition.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (cond
      ((null? gs) (g s))
      (else
       ((apply conj
          (cons (conj₂ g (car gs)) (cdr gs)))
        s)))))
\end{minted}

\noindent By η reducing over the definition, we produce a simple
variadic function. We show the result, and a comparable macro-based
definition in~\cref{mnt:conj-function-derived-definition}.

\begin{listing}
\begin{minted}[autogobble,stripall]{racket}
  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else
       (apply conj
         (cons (conj₂ g (car gs)) (cdr gs))))))

  (define-syntax conj
    (syntax-rules ()
      ((conj g) g)
      ((conj g g₁ gs ...)
       (conj (conj₂ g g₁) gs ...))))
\end{minted}
  \caption{Derived \rackinline|conj₂|-based function and macro.}
  \label{mnt:conj-function-derived-definition}
\end{listing}

Both the variadic function based and the macro based versions of
\cref{mnt:conj-function-derived-definition} use a left fold over the
goals, whereas the versions of \rackinline|disj| use a right fold.
This is not an accident, and we believe this is \emph{worth further
  consideration}. It is miniKanren folklore that left associating
conjunctions tends to improve miniKanren performance, but we have
generally resorted to small step visualizations of the search tree to
demonstrate why that might be. We can make an equally compelling
argument for this preference through equational reasoning.
\Cref{mnt:conj-right-fold-definition} shows a right-fold variant of
\rackinline|conj|. Looking at either the functional or macro
definitions built from \rackinline|conj₂|, it's difficult to assert
any preference for one over the other. The \rackinline|apply|
primitive and the macros both get in the way.

% The matter is so significant that the community might consider
% reclassifying left-associative conjunction as a matter of correctness
% rather than an optimization, as in \enquote{tail call optimization}
% vs. \enquote{Properly Implemented Tail Call
%   Handling}~\cite{felleisen2014requestions}.


\begin{listing}
\begin{minted}[autogobble,stripall]{racket}
  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else (conj₂ g (apply conj gs)))))
\end{minted}
  \caption{A right-fold variant of \rackinline|conj|.}
  \label{mnt:conj-right-fold-definition}
\end{listing}

The choice becomes a little more obvious after we η-expand, unfold to
a recursive help function, substitute in the definition of
\rackinline|conj₂|, and β-reduce.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else (append-map-∞ (apply C gs) (g s)))))
\end{minted}


\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else (append-map-∞ (apply C gs) (g s)))))
\end{minted}


Here, we cannot (easily) replace the \rackinline|apply| call by a
recursive call to \rackinline|C|, because we are still waiting for an
\rackinline|s|. We can only abstract over \rackinline|s| and wait.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (append-map∞
         (λ (s) (let ((t∞ ((car gs) s)))
                  (C (cdr gs) t∞)))
         s∞))))
\end{minted}

\noindent Since we know that any call to \rackinline|append-map∞| we
construct will always yield a result, the other one is tail recursive.
This version is not, and it builds closures. We can still reconstruct
the stream argument, and come up with an approximately analogous
right-fold version.

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (append-map-∞
         (λ (s) (C (cdr gs) ((car gs) s)))
         s∞))))
\end{minted}

So the equivalent right-fold implementation needs to construct a
closure for every recursive call. If we want to implement a variadic
version that does not rely on a primitive \rackinline|conj2| and does
not resort to \rackinline|apply|, we have the two aformentioned
choices. Basic programming horse sense suggests the variant from
\cref{mnt:conj-and-disj-reimplementation}.

Left associating conjuncts is so important that it dramatically
improves miniKanren's search. A full, thorough, explanation of the
behavior is outside the scope of our work here, but see discussions by
Rosenblatt and Ballantyne~\cite{here,nowhere}.

DONE UP UNTIL HERE

miniKanren's biased search heuristic causes some operational
differences between this reimplementation and the older one. With this
implementation, instead of the \emph{first} goal being the most
heavily weighted in the search, here the \emph{last} goal is most
heavily weighted. Because $n$-ary disjunction is now built in to the
functional definition, this behavior is now transparently visible in
the implementation of \rackinline|D|. Imagine for a moment that in
the given state \rackinline|s| each goal in \rackinline|(g₁ . gs)|
produces infinitely many answers. The \rackinline|append| is doing a
fair interleaving between its two stream arguments: giving one a
little time to work and then handing off to the other. At each
recursion, approximately half the answers in that stream come from the
most recently evaluated goal, and so the resources dedicated to all
the preceding goals is halved, in order to accommodate this new one.

Declarative programmers oughtn't need concern themselves with the
operational search behavior, and since miniKanren provides a complete
search, a query should still return the same bag of answers, so we do
not see this as a problem; we just consider it an interesting
distinction. If however operationally-aware programmers found the
\enquote{reversed weighting} unintuitive, some language front end
could rearrange the programmer's arguments. For example, reversing a
list of arguments is an exemplary use of an APS macro.

IS IT ACTUALLY SO? HOW WOULD I IMPLEMENT FOLD THE OTHER WAY.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (disj
   (conj (== a 'carmel-center)
         (== b 'golomb)
         (== c 'masada)
         (== d 'haneviim)
         (== e 'hadar-city-hall)
         (== f 'downtown))
   (conj (== a 'downtown)
         (== b 'hadar-city-hall)
         (== c 'haneviim)
         (== d 'masada)
         (== e 'golomb)
         (== f 'carmel-center))))
  \end{minted}
  \caption{A reimplemented Carmelit subway without \rackinline|conde|.}
  \label{mnt:new-carmelit}
\end{listing}

Though this note mainly concerns the choice to implement surface
language functionality as macros, it may also point to these as more
natural user-level primitives than \rackinline|conde|. An
implementation could choose to forego \rackinline|conde| and provide
just those underlying logical primitives \rackinline|conj| and
\rackinline|disj| to the user.

\section{Cleaning up the Impure Operators}\label{sec:impure}

The zero-ary conjunction and disjunction base cases both forced
primitive goals \rackinline|#s| and \rackinline|#f| into the language
and also hid the opportunity of functional left-fold implementations
as helpers to variadic surface functions. The zero-ary conjunction
case was itself implemented as an answer to an earlier problem in
implementing an \rackinline|if-then-else| soft-cut operator. The
zero-ary disjunction base case was not \emph{really} required, but
given that we needed one the other came along for the ride, so to
speak.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g₀ g ...)) (conj g₀ g ...))
    ((conda (g₀ g ...) ln ...)
     (ifte g₀ (conj g ...) (conda ln ...)))))

(define ((ifte g₁ g₂ g₃) s)
  (let loop ((s∞ (g₁ s)))
    (cond
      ((null? s∞) (g₃ s))
      ((pair? s∞)
       (append-map g₂ s∞))
      (else (lambda ()
              (loop (s∞)))))))
  \end{minted}
  \caption{A typical implementation of \rackinline|conda|.}
  \label{mnt:conda-implementation}
\end{listing}

The operators \rackinline|conda| and \rackinline|conde| look
superficially similar, syntactically. Semantically though, the
disjunction and nested \enquote{if-then-else} behaviors are quite
different, and implementing the desired behavior for this
\rackinline|conda| from existing combinators raises some oddities. The
definition of \rackinline|conda| already rules out zero-way
conjunctions of goals in the clause body as well as zero-way
disjunctions of such clauses. Another oddity is that, for a
\rackinline|conda| syntax that permits one-or-more-goals in each
clause, the final clause of the \rackinline|conda| definition is the
one and only place in the implementation that may require a nullary
conjunction of goals.

There are work-arounds. One could:

\begin{enumerate}

\item Special case one-goal clauses in the last clause of the
  \rackinline|conda| implementation with a special \rackinline|ifte|
  variant.

\item Special case that last clause by introducing \rackinline|#s| as
  an additional goal.

\item Mandate that all clauses in \rackinline|conda| contain at least two goals.

\item Mandate that all clauses \emph{except the final default clause} contain at
  least two goals.

\item Build a special-case conjunction solely for this purpose.
\end{enumerate}

In all but the first of these choices, either the implementation
implicitly or the syntax explicitly can force additional unneeded
executions of unwanted goals. The first choices seems even worse for
introducing another complex function definition that is nearly
identical to one used in the below case.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g₀ g ...)) (conj g₀ g ...))
    ((conda (g₀) ln ...)
     (ife g₀ (conda ln ...)))
    ((conda (g₀ g ...) ln ...)
     (ifte g₀ (conj g ...) (conda ln ...)))))

(define ((ife g₁ g₃) s)
  (let loop ((s∞ (g₁ s)))
    (cond
      ((null? s∞) (g₃ s))
      ((pair? s∞) s∞)
      (else (lambda ()
              (loop (s∞)))))))

(define ((ifte g₁ g₂ g₃) s)
  ...)
  \end{minted}
  \caption{An inauspicious re-implementation of \rackinline|conda|.}
  \label{mnt:conda-bad-re-implementation}
\end{listing}

Here too, removing macros and relying on variable arity function
definition provides a more elegant solution. Some programmers would be
perfectly satisfied to have lived forever with \rackinline|ifte|
itself. But just as the standard forked \rackinline|if| begat
McCarthy's \rackinline|if| notation and \rackinline|cond|, we can
suspect that a programmer would eventually feel the need for a nested
implementation.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define ((conda q a . q-and-a*) s)
  (A (q s) a q-and-a* s))

(define (A s∞ a q-and-a* s)
  (cond
    ((null? s∞)
     (cond
       ((null? (cdr q-and-a*)) ((car q-and-a*) s))
       (else (A ((car q-and-a*) s)
                    (cadr q-and-a*)
                    (cddr q-and-a*) s))))
    ((pair? s∞) (append-map∞ a s∞))
    (else (lambda () (A (s∞) a q-and-a* s)))))
  \end{minted}
  \caption{A functional \rackinline|conda| implementation.}
  \label{mnt:conda-good-re-implementation}
\end{listing}

The implementation in~\cref{mnt:conda-bad-re-implementation} includes
the delay-and-restart behavior of \rackinline|ifte| together with
\rackinline|conda|'s logical cascade.

\subsection{\rackinline|condu|}

We have not yet addressed~\rackinline|condu|. We could implement this
for functional programmers with a variant
of~\cref{mnt:conda-bad-re-implementation}. Instead, we choose to make
\rackinline|once| a primitive higher-order goal. This relies on a
local \rackinline|let|-bound named recursive procedure.

\begin{listing}
  \begin{minted}[autogobble,stripall]
    {racket}
(define (once g)
  (lambda (s)
    (let loop ((s∞ (g s)))
      (cond
        ((null? s∞) '())
        ((pair? s∞)
         (cons (car s∞) '()))
        (else (lambda ()
                (loop (s∞))))))))
  \end{minted}
  \caption{A functional \rackinline|once| implementation.}
  \label{mnt:condu-bad-re-implementation}
\end{listing}

\section{Conclusion}\label{sec:conclusion}

narrows the gap between implementations in functional host languages
with and without macro systems.

More languages than ever before support variable arity
functions/methods (aka \verb|varargs| aka \verb|slurpy| methods),
including Raku, Java, and Ruby, to name just a few. Many of these
languages also support polyvariadic functions. The authors hope that
this document helps implementers build more elegant, expressive and
efficient Kanrens in their chosen host languages.

Languages with variadic but without polyvariadic (that is to say
\enquote{at least $k$ arguments}) functions---how do they fare here?

This is closer to the design of Prolog,
where the user represents conjuction of goals in the body of a clause
with a comma and disjunction, either implicitly in listing various
clauses or explicitly with a semicolon.

Languages without expressive macro systems would still have to resort
to exposing implementations of streams and \emph{some} lower level
operations like introducing variables one at a time. But!

We take it as granted that conjunction and disjunction themselves are
sufficiently high-level operators for a surface language and that the
0-element base cases are at best unnecessary and likely undesireable.

Given the opportunity to define a surface language and its desugaring,
we really shouldn't tempt the programmer by making undesireable
programs representable when we can avoid doing so.

Of course, no implementer \emph{needs} a macro system to implement a
shallow embedding of an LP language. In our implementations, we still
use macros to implement \rackinline|defrel| and \rackinline|fresh|,
the former to prevent exposing the implementation of streams and
delays, and the latter both for the added efficiency and to avoid the
awkwardness of introducing each variable one at a time.

From time to time we find that the usual miniKanren implementation is
itself lower-level than we would like to program with relations.
Expert miniKanren programmers use macros to extend the language yet
again, as with \rackinline|matche|, and also with wholly more
expressive and highly optimized language forms, as in the original
\rackinline|Kanren|. It is nice to find we can spread some of that
extra expressiveness to the wider Kanren language community.

Early microKanren implementations restrict themselves to
\rackinline|syntax-rules| macros. Several more powerful syntax
constructions over miniKanren may rely on more expressive macro
systems, including Ballantyne's
\rackinline|minikanren-ee|~\cite{ballantyne2020macros}.

This note shows that at the cost of one additional feature--namely
variadic functions---implementers provide a somewhat more powerful
core language and significantly reduce the need for macros in
implementing a language as expressive as the full
\verb|microKanren + Macros| approach provides.

Our desugaring macros would have worked whether we left or right
associated. Removing a degree of freedom in the implementation, and
forcing ourselves to program the solution functionally, led us to what
seems like the right solution.

\begin{acks}

  Thanks also to Ken Shan and Jeremy Siek, for helpful discussions and
  debates during design decision deliberations. Greg Rosenblatt for
  his discussion later

\end{acks}

\printbibliography{}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
