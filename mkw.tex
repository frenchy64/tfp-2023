\documentclass[sigplan,draft,natbib=false]{acmart}
%% ∞
%% …
%% ₀
%% ₁
%% ₂
%% ₃
\usepackage{fontspec,newunicodechar}
\usepackage{hyphenat} %% electromagnetic\hyp{}endioscopy
\usepackage[shortcuts]{extdash}
\usepackage{microtype} %% provides tighter text formatting
\usepackage{polyglossia} %% for xelatex use polyglossia, needed for csquotes
\setdefaultlanguage[variant=american]{english}

\PassOptionsToPackage{cache=false,newfloat=true}{minted}
\PassOptionsToPackage{unicode}{hyperref}

\usepackage[capitalize,nameinlink]{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\RequirePackage[
  datamodel=acmdatamodel,
  style=acmnumeric,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{mkw.bib}

\usepackage{nag} %% should complain about old and outdated commands
\usepackage{minted}
\usepackage[strict,autostyle]{csquotes} %% enquote &c that doesn't interfere w/cdlatex usage
%% http://ftp.lyx.org/pub/tex-archive/macros/latex/contrib/csquotes/csquotes.pdf
%% \usepackage[xspace]{ellipsis} they suggest using xetex instead
%% \usepackage{setspace} %% set the spacing (single double, etc)

\setmonofont{DejaVuSansMono}[Scale=MatchLowercase]
\tracinglostchars=2
\usepackage[defaultlines=3,all]{nowidow} %% Eliminates widow and orphans
\usepackage{todonotes}

\newmintinline[rackinline]{racket}{}
\newmintinline{prolog}{}

\setcopyright{acmcopyright}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[mKW '22]{miniKanren Workshop}{September 15,
  2022}{Ljubljana, Slovenia}

\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}

\begin{document}

\title[Some Criteria for Implementations of conj and disj in
microKanren]{Some Criteria for Implementations of Disjunction and
  Conjunction in microKanren}

\author{Jason Hemann}
\email{jhemann@northeastern.edu}
\orcid{1234-5678-9012}
\author{Daniel P. Friedman}
\email{dfried@cs.indiana.edu}
\orcid{1234-5678-9012}

\renewcommand{\shortauthors}{Hemann et al.}

\begin{abstract}
  We describe how an extra host language feature---namely variadic,
  \enquote{rest argument} functions---permit the shallow embedding of
  a more powerful but still ergonomic kernel language. We implement
  disjunction and conjunction functions that preserve search order and
  that do not create superfluous closures. The result is a shorter and
  simpler overall implementation that is more elegant.
\end{abstract}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011015</concept_id>
       <concept_desc>Software and its engineering~Constraint and logic languages</concept_desc>
       <concept_significance>500</concept_significance>
   </concept>
   <concept>
       <concept_id>10003752.10003790.10003795</concept_id>
       <concept_desc>Theory of computation~Constraint and logic programming</concept_desc>
       <concept_significance>300</concept_significance>
   </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Constraint and logic languages}
\ccsdesc[500]{Software and its engineering~Automatic programming}

%%
 %% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{logic programming, miniKanren, DSLs, embedding, macros}

\maketitle

\section{Introduction}

microKanren~\cite{hemann2013muKanren} is a compact approach to
implementing a relational programming language. The microKanren
approach has worked out well as a tool for understanding the guts of a
relational programming language through studying its implementation.
The microKanren reimplementation separates surface syntax macros from
function definitions. In doing so, the authors hoped this separation
would simultaneously aid future would-be implementers when studying
the source code, and also that the functional core would make the
language easier to port to other functional hosts. To support both
those efforts, they also chose to program in a deliberately small and
workaday set of Scheme primitives.

More languages than ever before support variable arity
functions/methods (aka \verb|varargs| aka \verb|slurpy| methods),
including JavaScript, Raku, Java, Python, and Ruby, to name just a
few. This note shows how an implementer in a host language with
variadic (any number of arguments) functions can build a somewhat more
powerful kernel language and obviate some macros, including those for
disjunction and conjunction. Until now there was a large gap between
those microKanren implementations in languages with expressive macro
systems and those without; variadic functions permit an intermediate
point in the language design space. Implementers in languages
\emph{with} macro systems may even choose to replace existing less
powerful language primitives by our comparatively short but more
powerful variants.

Beyond being a conceptually simpler foundation for a full Kanren
language at the level of \citetitle{friedman2018reasoned}, this
implementation may even be more efficient.\ miniKanren folklore
conjectures that right-associative conjunction is an inefficient
design choice. We were pleasantly surprised that thinking about the
expressivity of primitives and code improvement \enquote{horse sense}
led us to the same improved design.

In \cref{sec:all-aboard}, we briefly revisit microKanren
implementations and illustrate why surface syntax macros had seemed
practically mandatory. In
\cref{sec:conde}, we implement conjunction
and disjunction, and in \cref{sec:impure} we discuss the
re-implementation of the impure operators. We close with a discussion
of some performance impacts of these implementation choices, and
consider how Kanren language implementers outside of the Scheme family
might benefit from these alternatives.

\section{All Aboard!}\label{sec:all-aboard}

We assume the reader is familiar with the miniKanren language as
described in \citetitle{friedman2018reasoned} and in particular with
microKanren implementations. See \href{minikanren.org}{minikanren.org}
for many implementations across multiple host languages.

The world's shortest subway system is Haifa's Carmelit, with only
six stations. The system is a line, so its trains travel back and
forth. If we wanted to describe the order in which we rode the train
from the beginning to the end, we could use the
\rackinline|carmelit-subway| relation in \cref{mnt:carmelit}. We
express this relation using the more compact miniKanren syntax because
unfolding this relation into binary conjunctions and disjunctions
would be painful. We certainly \emph{could} write it out by hand---in
fact, we could write it out many ways. We could nest those
conjunctions to the left, or to the right, or try and reduce the
indentation by trying to keep them somewhat balanced: the program
itself does not seem to obviously encourage one particular choice.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (conde
    ((== a 'carmel-center)
     (== b 'golomb)
     (== c 'masada)
     (== d 'haneviim)
     (== e 'hadar-city-hall)
     (== f 'downtown))
    ((== a 'downtown)
     (== b 'hadar-city-hall)
     (== c 'haneviim)
     (== d 'masada)
     (== e 'golomb)
     (== f 'carmel-center))))
  \end{minted}
  \caption{A miniKanren version of the Carmelit subway}
  \label{mnt:carmelit}
\end{listing}

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conde
  (syntax-rules ()
    ((conde (g ...) ...)
     (disj (conj g ...) ...))))

(define-syntax disj
  (syntax-rules ()
    ((disj) #u)
    ((disj g) g)
    ((disj g₀ g ...) (disj₂ g₀ (disj g ...)))))

(define ((disj₂ g₁ g₂) s)
  (append∞ (g₁ s) (g₂ s)))

(define-syntax conj
  (syntax-rules ()
    ((conj) #s)
    ((conj g) g)
    ((conj g₀ g ...) (conj₂ g₀ (conj g ...)))))

(define ((conj₂ g₁ g₂) s)
  (append-map∞ g₂ (g₁ s)))
  \end{minted}
  \caption{Macro based implementations of  \rackinline|disj| and \rackinline|conj|}
  \label{mnt:conj-and-disj-implementation}
\end{listing}

\Cref{mnt:conj-and-disj-implementation} shows typical macro-based
implementations of \rackinline|conde| and the underlying conjunction
and disjunction operations. Here, \rackinline|#s| and \rackinline|#u|
represent primitive goals that unconditionally succeed and fail,
respectively.

\section{\rackinline|disj| and \rackinline|conj| logical goal
  constructors}\label{sec:conde}

The  \rackinline|disj| and \rackinline|conj| macros of
\cref{mnt:conj-and-disj-implementation} are not \emph{quite} defined
as simple recursions over their binary functional primitives. The
definition of zero-way conjunction (disjunction) is independent of the
unfolding of \rackinline|conj₂| (\rackinline|disj₂|). In a sense the
\rackinline|disj| and \rackinline|conj| macros confuse and entangle
primitive success and failure goals with those recursive unfoldings in
terms of the binary operators.

Those zero-way logical operation base cases don't add much. The
programmer who tries to write an elegant, efficient solution to a pure
relational programming task would not encounter these additional base
cases in \rackinline|conde| expressions. The programmer knows
statically how such goals should behave, so there is no benefit to
executing them. A conjunction of no goals would simply succeed, and a
disjunction of no goals would simply fail. Truthfully, only the impure
\rackinline|conda| operator seems to require these additional base
cases (discussed further in \cref{sec:impure}). They are for all
intents and purposes superfluous.

Here, we want to implement disjunction and conjunction over
one-or-more goals as functions. These implementations will rely on
variadic function syntax, but should not require \rackinline|apply| or
rely on the binary \rackinline|disj₂| and \rackinline|conj₂|. Further,
they should not build any extraneous closures: unnecessarily building
closures at runtime is always a bad idea.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((disj g . gs) s)
    (D (g s) gs s))

  (define (D s∞ gs s)
    (cond
      ((null? gs) s∞)
      (else
       (append∞ s∞
         (D ((car gs) s) (cdr gs) s)))))
  \end{minted}
  \caption{Eventual redefinition of \rackinline|disj|}
  \label{mnt:disj-reimplementation}
\end{listing}

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (C (cdr gs)
          (append-map∞ (car gs) s∞)))))
  \end{minted}
  \caption{Eventual redefinition of \rackinline|conj|}
  \label{mnt:conj-reimplementation}
\end{listing}

\Cref{mnt:disj-reimplementation,mnt:conj-reimplementation} show our
new implementations. Mandating one-or-more arguments lets us
re-implement these operators as shallow wrappers over simple folds.
The first step in each is merely to remove the rest argument
\rackinline|gs| and act as if there were no need for a rest argument.
That is, all of our focus will be on the \emph{list}, \rackinline|gs|.
Unlike \rackinline|D|, the function \rackinline|C| does not take in
the state \rackinline|s|; the help procedure does not need the state
for conjunction. In each recursive call, we accumulate by mapping
(using the special delaying implementation of append-map for
miniKanren streams) the next goal in the list. This left-fold
implementation of conjunction therefore left-associates the conjuncts.

\subsection{Semantic equivalence}

Equipped with variadic functions, a developer might discover these
definitions as follows. We start from the definition of the
\rackinline|disj| macro in \cref{mnt:disj-function-before-derivation}.
At the cost of an \rackinline|apply|, we can build the corresponding
explicitly recursive \rackinline|disj| function.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define-syntax disj
  (syntax-rules ()
    ((disj g) g)
    ((disj g₀ g₁ g ...)
     (disj₂ g₀ (disj g₁ g ...)))))

(define (disj g . gs)
  (cond
    ((null? gs) g)
    (else (disj₂ g (apply disj gs)))))
\end{minted}
  \caption{Deriving \rackinline|disj| function from macro}
  \label{mnt:disj-function-before-derivation}
\end{listing}

\noindent Since \rackinline|disj| produces and consumes goals, we can
η expand the definition in \cref{mnt:disj-function-before-derivation}
by a curried parameter \rackinline|s|. We then split \rackinline|disj|
into two mutually-recursive procedures, to build the variant in
\cref{mnt:disj-function-split}.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define ((disj g . gs) s)
  (D g gs s))

(define (D g gs s)
  (cond
    ((null? gs) (g s))
    (else ((disj₂ g (apply disj gs)) s))))
\end{minted}
  \caption{An η expanded and split definition of \rackinline|disj|}
  \label{mnt:disj-function-split}
\end{listing}

\noindent We can replace the call to \rackinline|disj₂| in
\cref{mnt:disj-function-split} by its definition in terms of
\rackinline|append∞| and perform a trivial β-reduction. The explicit
\rackinline|s| argument suggests removing the call to
\rackinline|apply| and making \rackinline|D| recursive. The result is
the version of \rackinline|D| in \cref{mnt:disj-substituted-through}.
The definition of \rackinline|disj| remains unchanged from
\cref{mnt:disj-function-split}.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define (D g gs s)
  (cond
    ((null? gs) (g s))
    (else
      (append∞ (g s)
        (D (car gs) (cdr gs) s)))))
\end{minted}
  \caption{Derivation of \rackinline|disj| function definition}
  \label{mnt:disj-substituted-through}
\end{listing}

\noindent We combine \rackinline|g| and \rackinline|s| in each clause;
this suggests constructing that stream in \rackinline|disj| and
passing it along. Making this final change results in the definition
in~\cref{mnt:disj-reimplementation}.


\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
(define-syntax conj
  (syntax-rules ()
    ((conj g) g)
    ((conj g g₁ gs ...)
     (conj (conj₂ g g₁) gs ...))))

(define (conj g . gs)
  (cond
    ((null? gs) g)
    (else
     (apply conj
       (cons (conj₂ g (car gs)) (cdr gs))))))
\end{minted}
  \caption{\rackinline|conj₂|-based \rackinline|conj| function and macro}
  \label{mnt:conj-function-derived-definition}
\end{listing}

We can derive the definition of \rackinline|conj| from
\cref{mnt:conj-reimplementation} via a similar process. Starting with
the variadic function based on the macro in
\cref{mnt:conj-function-derived-definition}, we first η-expand and
split the definition.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C g gs s))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       ((apply conj
          (cons (conj₂ g (car gs)) (cdr gs)))
        s))))
\end{minted}
  \caption{Derivation of split \rackinline|conj| function definition}
  \label{mnt:conj-substituted-through}
\end{listing}
\noindent We next substitute for the definitions of \rackinline|conj| and
\rackinline|conj₂|.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else
       (C (λ (s) (append-map∞ (car gs) (g s)))
          (cdr gs)
          s))))
\end{minted}
  \caption{Replacing \rackinline|apply| in \rackinline|C| function definition}
  \label{mnt:C-substituted-through}
\end{listing}

Finally, since \rackinline|C| only needs \rackinline|s| to
\emph{build} the stream, we can assemble the stream on the way
in---instead of passing in \rackinline|g| and \rackinline|s|
separately, we pass in their combination as a stream. The function is
tail recursive, we can change the signature in the one and only
external call and the recursive call. We show the result
in \cref{mnt:conj-reimplementation}.

Both the variadic function based and the macro based versions of
\cref{mnt:conj-function-derived-definition} use a left fold over the
goals, whereas the versions of \rackinline|disj| use a right fold.
This is not an accident. It is miniKanren folklore that left
associating conjunctions tends to improve miniKanren performance. A
full, thorough, explanation of everything known about this behavior is
outside the scope of our work here, but see discussions and
implementation of \cite{rosenblatt2019first}. The matter seems so
significant that the community might consider reclassifying
left-associative conjunction as a matter of correctness rather than an
optimization, as in \enquote{tail call optimization} vs.
\enquote{Properly Implemented Tail Call
  Handling}~\cite{felleisen2014requestions}. However, we have
generally resorted to small step visualizations of the search tree to
demonstrate why that might be. The authors believe it is worth
considering if we can make an equally compelling argument for this
preference through equational reasoning.
\Cref{mnt:conj-right-fold-definition} shows a right-fold variant of
\rackinline|conj|. The choice to fold left becomes a little more
obvious after we η-expand, unfold to a recursive help function,
substitute in the definition of \rackinline|conj₂|, and β-reduce.

\begin{listing}[h]
\begin{minted}[autogobble,stripall]{racket}
  (define (conj g . gs)
    (cond
      ((null? gs) g)
      (else (conj₂ g (apply conj gs)))))
\end{minted}
  \caption{A right-fold variant of \rackinline|conj|}
  \label{mnt:conj-right-fold-definition}
\end{listing}

\begin{minted}[autogobble,stripall]{racket}
  (define ((conj g . gs) s)
    (C gs (g s)))

  (define (C g gs s)
    (cond
      ((null? gs) (g s))
      (else (append-map-∞ (apply C gs) (g s)))))
\end{minted}

\noindent Here, we cannot (easily) replace the \rackinline|apply| call
by a recursive call to \rackinline|C|, because we are still waiting
for an \rackinline|s|. We can only abstract over \rackinline|s| and
wait.

\begin{minted}[autogobble,stripall]{racket}
  (define (C gs s∞)
    (cond
      ((null? gs) s∞)
      (else
       (append-map∞
         (λ (s) (C (cdr gs) ((car gs) s)))
         s∞))))
\end{minted}

Since we know that any call to \rackinline|append-map∞| we construct
will always yield a result, the version in
\cref{mnt:conj-reimplementation} is tail recursive. The equivalent
right-fold implementation needs to construct a closure for every
recursive call. If we want to implement a variadic version that does
not rely on a primitive \rackinline|conj2| and does not resort to
\rackinline|apply|, we have the two aformentioned choices. Basic
programming horse sense suggests the variant from
\cref{mnt:conj-reimplementation}.

Though this note mainly concerns the choice to implement surface
language behavior as functions, it may also point to these as more
natural user-level primitives than \rackinline|conde|. An
implementation could choose to forego \rackinline|conde| and provide
just those underlying logical primitives \rackinline|disj| and
\rackinline|conj| to the user, as in the new definition of Carmelit in
\cref{mnt:new-carmelit}. Moreover, reintroducing the nullary case only
requires a simple wrapper macro, or otherwise, a run-time
\rackinline|null?| check for a very slight cost.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(defrel (carmelit-subway a b c d e f)
  (disj
    (conj (== a 'carmel-center)
          (== b 'golomb)
          (== c 'masada)
          (== d 'haneviim)
          (== e 'hadar-city-hall)
          (== f 'downtown))
    (conj (== a 'downtown)
          (== b 'hadar-city-hall)
          (== c 'haneviim)
          (== d 'masada)
          (== e 'golomb)
          (== f 'carmel-center))))
  \end{minted}
  \caption{A new Carmelit subway without \rackinline|conde|}
  \label{mnt:new-carmelit}
\end{listing}

\section{Tidying up the Impure Operators}\label{sec:impure}

The operators \rackinline|conda| and \rackinline|conde| look
superficially similar, syntactically. Semantically though,
\rackinline|conda|'s nested \enquote{if-then-else} behavior is quite
different, and implementing the desired behavior for
\rackinline|conda| from existing pieces points to some strangeness.
The definition of \rackinline|conda| (see
\cref{mnt:conda-implementation}) requires one or more conjuncts per
clause and one or more clauses. The consequent of each
\rackinline|conda| clause is the one and only place in the whole
language implementation that permits nullary conjunctions of goals.
This soft-cut operator seems to force both nullary conjunction and
those primitive goals \rackinline|#s| and \rackinline|#u| into the
language.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define-syntax conda
  (syntax-rules ()
    ((conda (g₀ g ...)) (conj g₀ g ...))
    ((conda (g₀ g ...) ln ...)
     (ifte g₀ (conj g ...) (conda ln ...)))))

(define ((ifte g₁ g₂ g₃) s)
  (let loop ((s∞ (g₁ s)))
    (cond
      ((null? s∞) (g₃ s))
      ((pair? s∞)
       (append-map g₂ s∞))
      (else (lambda ()
              (loop (s∞)))))))
  \end{minted}
  \caption{A typical implementation of \rackinline|conda|}
  \label{mnt:conda-implementation}
\end{listing}

Some programmers would be perfectly satisfied just using
\rackinline|ifte| directly. But just as the standard forked
\rackinline|if| begat McCarthy's \rackinline|if| notation and
\rackinline|cond|, we can suspect that a programmer would eventually
feel the need for a nested implementation. There are other alternative
implementation choices one could consider.

\begin{enumerate}

\item Syntactically mandate that all clauses \emph{except the final
    default clause} contain at least two goals.

\item Introduce a special clause of the \rackinline|conda| macro
  specifically for \enquote{if then} clauses with a single goal.

\item Unconditionally add an a \rackinline|#s| goal to each clause
  during macro expansion.

\end{enumerate}

Each of these choices can, implicitly or explicitly, force additional
unneeded executions of unwanted goals. Working with variable arity
function syntax also suggests a more elegant solution for
\rackinline|conda|.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define ((conda q a . q-and-a*) s)
  (A (q s) a q-and-a* s))

(define (A s∞ a q-and-a* s)
  (cond
    ((null? s∞)
     (cond
       ((null? (cdr q-and-a*)) ((car q-and-a*) s))
       (else (A ((car q-and-a*) s)
                (cadr q-and-a*)
                (cddr q-and-a*)
                s))))
    ((pair? s∞) (append-map∞ a s∞))
    (else (lambda () (A (s∞) a q-and-a* s)))))
  \end{minted}
  \caption{A functional \rackinline|conda| implementation}
  \label{mnt:conda-good-re-implementation}
\end{listing}

The implementation in \cref{mnt:conda-good-re-implementation} includes
the delay-and-restart behavior of \rackinline|ifte| together with
\rackinline|conda|'s logical cascade. The \rackinline|s∞| can be
either empty, non-empty, or a function of no arguments. In the last
case, we invoke \rackinline|s∞|. Rather than building a largely
redundant implementation of \rackinline|condu|, we expose the
higher-order goal \rackinline|once| to the user. The definition of
\rackinline|once| in \cref{mnt:condu-reimplementation} is taken
directly from \cite{friedman2018reasoned}. The programmer can simulate
\rackinline|condu| by wrapping \rackinline|once| around every test
goal.


\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define (once g)
  (lambda (s)
    (let loop ((s-inf (g s)))
      (cond
        ((null? s-inf) '())
        ((pair? s-inf)
         (cons (car s-inf) '()))
        (else (lambda ()
                (loop (s-inf))))))))
  \end{minted}
  \caption{The \rackinline|once| function}
  \label{mnt:condu-reimplementation}
\end{listing}


\section{Macro-free microKanren}\label{sec:functional}

In this section we collect together some workarounds to obviate macros
in some other language features. With these, a programmer in a
pedestrian functional language should be able to directly translate
the implementation and our test programs.

\paragraph{\rackinline|define|} The microKanren programmer can just
use their host language's \rackinline|define| feature to construct
relations as host-language functions, and manually introduce the
delays in relations. This may be a larger concession than it looks,
since it exposes the delay and interleave mechanism to the user, and
both correct interleaving and even the termination of relation
\emph{definitions} rely on a whole-program correctness property of
relation definitions having a delay. \Cref{mnt:subtleo} relies on a
help function \rackinline|Zzz| to introduce delays, akin to some
earlier implementations~\cite{hemann2013muKanren}.


\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(define (subtleo x)
  (Zzz
    (disj
      (subtleo x)
      (== x 'cat))))
  \end{minted}
  \caption{Omitting the delay is a subtle bug}
  \label{mnt:subtleo}
\end{listing}

\paragraph{\rackinline|fresh|} In any implementation there must be
some mechanism to produce the next fresh variable. For example, we
treat the natural numbers as an indexed set of variables, and we
thread the current index through the computation. We use
\rackinline|add1| to get the next index; to go from index to variable
is the identity function. For another example, we could represent each
variable using a unique memory location,
sokuza-kanren~\cite{kiselyov2006taste} style, and the operation to
produce a new variable requires introducing an unused memory location.
Depending on the implementation of variables, you may also need
additional functions to support your implementation of variables. If
variables are not from an indexed set, you may also need an operation
to (re)construct specifically the first element of the set, or
otherwise store that value for later re-use.

Of course, one of these approaches requires memory allocation and
external global state, while the other does not. Furthermore, the
latter approach models logic variables as coming from a single global
pool rather than reusing them separately across each disjunct, and so
requires some global store and strictly more logic variables overall.

With this latter approach, however, we can expose \rackinline|var|
directly to the programmer and the programmer can use \rackinline|let|
bindings to introduce several logic variables simultaneously.

\paragraph{\rackinline|run|}

For the reader interested in removing macros, we note that we can also
implement \rackinline|run| without using macros. Using the
purely-functional implementation of logic variables, the definitions
of \rackinline|run| and \rackinline|run*| easily translate to
functions like
\rackinline|call/initial-state|~\cite{hemann2013muKanren}. The query
is itself expressed as a goal that introduces the first logic variable
\rackinline|q|. The pointer-based logic variable approach forces the
programmer to explicitly invoke \rackinline|reify| as though it were a
goal as the last step of executing the query, as in
\cref{mnt:run-query}.

\begin{listing}
  \begin{minted}[autogobble,stripall]{racket}
(call/initial-state 1
  (let ((q (var 'q)))
    (conj
      (let ((x (var 'x)))
        (== q x))
      (reify q))))
  \end{minted}
  \caption{Queries as expressed with global-state variables}
  \label{mnt:run-query}
\end{listing}

These are the wages of sin.

\section{Conclusion}\label{sec:conclusion}

This note shows that at the cost of one additional feature---namely,
variadic functions---implementers provide a somewhat more powerful
core language and significantly reduce the need for macros in
implementing a language as expressive as the full \enquote{microKanren
  + macros} approach provides. Our desugaring macros would have worked
whether we left or right associate. Removing a degree of freedom in
the implementation, and forcing ourselves to program the solution
functionally, led us to what seems like the right solution.

The result is closer to the design of Prolog, where the user
represents conjunction of goals in the body of a clause with a comma
and disjunction, either implicitly in listing various clauses or
explicitly with a semicolon.

We assume it is agreed that our definitions of \rackinline|disj| and
\rackinline|conj| themselves are sufficiently high-level operators for
a surface language and that the zero-element base cases are at best
unnecessary and likely undesirable; given the opportunity to define a
surface language and its desugaring, we really shouldn't tempt the
programmer by making undesirable programs representable when we can
avoid it.

Scheme's polyvariadic function syntax (that is to say \enquote{at
  least $k$ arguments}, for some positive integer $k$) ensures at a
host-language level that the microKanren programmer provides at least
one parameter to \rackinline|conj| and \rackinline|disj|. Embeddings
in languages with variadic but without polyvariadic function syntax
would have to implement that check.

We have not fully obviated the use of macros. While neither
\rackinline|run| nor \rackinline|run*| have to be macros, for now we
still want to implement \rackinline|defrel| and \rackinline|fresh|
with macros. The former to prevent exposing the implementation of
streams and delays, and the latter to avoid the inefficiency and
clumsiness of introducing variables one at a time.

From time to time we find that the usual miniKanren implementation is
itself lower-level than we would like to program with relations. Early
microKanren implementations restrict themselves to
\rackinline|syntax-rules| macros. Some programmers use macros to
extend the language further as with
\rackinline|matche|~\cite{keep2009pattern}. Some constructions over
miniKanren, such as
\rackinline|minikanren-ee|~\cite{ballantyne2020macros}, may rely on
more expressive macro systems like
\rackinline|syntax-parse|~\cite{culpepper2012fortifying}.

We would still like to know: are our design goals here also causally
related to good miniKanren performance? Regardless, we hope this
document helps narrow the gap between implementations in functional
host languages with and without macro systems and helps implementers
build more elegant, expressive and efficient Kanrens in their chosen
host languages.

\begin{acks}

  Thanks also to Ken Shan and Jeremy Siek, for helpful discussions and
  debates during design decision deliberations. Thanks also to Greg
  Rosenblatt and Michael Ballantyne for their insights and
  suggestions.

\end{acks}

\printbibliography{}
%% \enlargethispage{\baselineskip}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
